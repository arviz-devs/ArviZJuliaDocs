var documenterSearchIndex = {"docs":
[{"location":"api/rcparams/#rcparams-api","page":"rcParams","title":"rcParams","text":"","category":"section"},{"location":"api/rcparams/","page":"rcParams","title":"rcParams","text":"Pages = [\"rcparams.md\"]","category":"page"},{"location":"api/rcparams/#Reference","page":"rcParams","title":"Reference","text":"","category":"section"},{"location":"api/rcparams/","page":"rcParams","title":"rcParams","text":"Modules = [ArviZPythonPlots]\nPages   = [\"rcparams.jl\"]\nPrivate = false","category":"page"},{"location":"api/rcparams/#ArviZPythonPlots.rcParams","page":"rcParams","title":"ArviZPythonPlots.rcParams","text":"Class to contain ArviZ default parameters.\n\n    It is implemented as a dict with validation when setting items.\n    \n\n\n\n\n\n\n","category":"constant"},{"location":"api/rcparams/#ArviZPythonPlots.rc_context-Tuple","page":"rcParams","title":"ArviZPythonPlots.rc_context","text":"\n    Return a context manager for managing rc settings.\n\n    Parameters\n    ----------\n    rc : dict, optional\n        Mapping containing the rcParams to modify temporally.\n    fname : str, optional\n        Filename of the file containing the rcParams to use inside the rc_context.\n\n    Examples\n    --------\n    This allows one to do::\n\n        with az.rc_context(fname='pystan.rc'):\n            idata = az.load_arviz_data(\"radon\")\n            az.plot_posterior(idata, var_names=[\"gamma\"])\n\n    The plot would have settings from 'screen.rc'\n\n    A dictionary can also be passed to the context manager::\n\n        with az.rc_context(rc={'plot.max_subplots': None}, fname='pystan.rc'):\n            idata = az.load_arviz_data(\"radon\")\n            az.plot_posterior(idata, var_names=[\"gamma\"])\n\n    The 'rc' dictionary takes precedence over the settings loaded from\n    'fname'. Passing a dictionary only is also valid.\n    \n\n\n\n\n\n\n","category":"method"},{"location":"api/#api","page":"API Overview","title":"API Overview","text":"","category":"section"},{"location":"api/","page":"API Overview","title":"API Overview","text":"Pages = [\"style.md\", \"rcparams.md\", \"plots.md\"]\nDepth = 1","category":"page"},{"location":"examples/#Example-Gallery","page":"Examples gallery","title":"Example Gallery","text":"","category":"section"},{"location":"examples/#Autocorrelation-Plot","page":"Examples gallery","title":"Autocorrelation Plot","text":"","category":"section"},{"location":"examples/","page":"Examples gallery","title":"Examples gallery","text":"using ArviZPythonPlots, ArviZExampleData\n\nuse_style(\"arviz-darkgrid\")\n\ndata = load_example_data(\"centered_eight\")\nplot_autocorr(data; var_names=[\"tau\", \"mu\"])\ngcf()","category":"page"},{"location":"examples/","page":"Examples gallery","title":"Examples gallery","text":"See plot_autocorr","category":"page"},{"location":"examples/#Bayes-Factor-Plot","page":"Examples gallery","title":"Bayes Factor Plot","text":"","category":"section"},{"location":"examples/","page":"Examples gallery","title":"Examples gallery","text":"using ArviZ, ArviZPythonPlots\n\nuse_style(\"arviz-darkgrid\")\n\nidata = from_namedtuple((a = 1 .+ randn(5_000) ./ 2,), prior=(a = randn(5_000),))\nplot_bf(idata; var_name=\"a\", ref_val=0)\ngcf()","category":"page"},{"location":"examples/","page":"Examples gallery","title":"Examples gallery","text":"See plot_bf","category":"page"},{"location":"examples/#Bayesian-P-Value-Posterior-Plot","page":"Examples gallery","title":"Bayesian P-Value Posterior Plot","text":"","category":"section"},{"location":"examples/","page":"Examples gallery","title":"Examples gallery","text":"using ArviZPythonPlots, ArviZExampleData\n\nuse_style(\"arviz-darkgrid\")\n\ndata = load_example_data(\"regression1d\")\nplot_bpv(data)\ngcf()","category":"page"},{"location":"examples/","page":"Examples gallery","title":"Examples gallery","text":"See plot_bpv","category":"page"},{"location":"examples/#Bayesian-P-Value-with-Median-T-Statistic-Posterior-Plot","page":"Examples gallery","title":"Bayesian P-Value with Median T Statistic Posterior Plot","text":"","category":"section"},{"location":"examples/","page":"Examples gallery","title":"Examples gallery","text":"using ArviZPythonPlots, ArviZExampleData\n\nuse_style(\"arviz-darkgrid\")\n\ndata = load_example_data(\"regression1d\")\nplot_bpv(data; kind=\"t_stat\", t_stat=\"0.5\")\ngcf()","category":"page"},{"location":"examples/","page":"Examples gallery","title":"Examples gallery","text":"See plot_bpv","category":"page"},{"location":"examples/#Compare-Plot","page":"Examples gallery","title":"Compare Plot","text":"","category":"section"},{"location":"examples/","page":"Examples gallery","title":"Examples gallery","text":"using ArviZ, ArviZPythonPlots, ArviZExampleData\n\nuse_style(\"arviz-darkgrid\")\n\nmodel_compare = compare(\n    (\n        var\"Centered 8 schools\" = load_example_data(\"centered_eight\"),\n        var\"Non-centered 8 schools\" = load_example_data(\"non_centered_eight\"),\n    ),\n)\nplot_compare(model_compare; figsize=(12, 4))\ngcf()","category":"page"},{"location":"examples/","page":"Examples gallery","title":"Examples gallery","text":"See compare, plot_compare","category":"page"},{"location":"examples/#Density-Plot","page":"Examples gallery","title":"Density Plot","text":"","category":"section"},{"location":"examples/","page":"Examples gallery","title":"Examples gallery","text":"using ArviZPythonPlots, ArviZExampleData\n\nuse_style(\"arviz-darkgrid\")\n\ncentered_data = load_example_data(\"centered_eight\")\nnon_centered_data = load_example_data(\"non_centered_eight\")\nplot_density(\n    [centered_data, non_centered_data];\n    data_labels=[\"Centered\", \"Non Centered\"],\n    var_names=[\"theta\"],\n    shade=0.1,\n)\ngcf()","category":"page"},{"location":"examples/","page":"Examples gallery","title":"Examples gallery","text":"See plot_density","category":"page"},{"location":"examples/#Dist-Plot","page":"Examples gallery","title":"Dist Plot","text":"","category":"section"},{"location":"examples/","page":"Examples gallery","title":"Examples gallery","text":"using ArviZPythonPlots, Distributions, Random\n\nRandom.seed!(308)\n\nuse_style(\"arviz-darkgrid\")\n\na = rand(Poisson(4), 1000)\nb = rand(Normal(0, 1), 1000)\n_, ax = subplots(1, 2; figsize=(10, 4))\nplot_dist(a; color=\"C1\", label=\"Poisson\", ax=ax[0])\nplot_dist(b; color=\"C2\", label=\"Gaussian\", ax=ax[1])\ngcf()","category":"page"},{"location":"examples/","page":"Examples gallery","title":"Examples gallery","text":"See plot_dist","category":"page"},{"location":"examples/#Dot-Plot","page":"Examples gallery","title":"Dot Plot","text":"","category":"section"},{"location":"examples/","page":"Examples gallery","title":"Examples gallery","text":"using ArviZPythonPlots\n\nuse_style(\"arviz-darkgrid\")\n\ndata = randn(1000)\nfigure() # hide\nplot_dot(data; dotcolor=\"C1\", point_interval=true)\ntitle(\"Gaussian Distribution\")\ngcf()","category":"page"},{"location":"examples/","page":"Examples gallery","title":"Examples gallery","text":"See plot_dot","category":"page"},{"location":"examples/#ECDF-Plot","page":"Examples gallery","title":"ECDF Plot","text":"","category":"section"},{"location":"examples/","page":"Examples gallery","title":"Examples gallery","text":"using ArviZPythonPlots, Distributions\n\nuse_style(\"arviz-darkgrid\")\n\nsample = randn(1_000)\ndist = Normal()\nplot_ecdf(sample; cdf=x -> cdf(dist, x), confidence_bands=true)\ngcf()","category":"page"},{"location":"examples/","page":"Examples gallery","title":"Examples gallery","text":"See plot_ecdf","category":"page"},{"location":"examples/#ELPD-Plot","page":"Examples gallery","title":"ELPD Plot","text":"","category":"section"},{"location":"examples/","page":"Examples gallery","title":"Examples gallery","text":"using ArviZPythonPlots, ArviZExampleData\n\nuse_style(\"arviz-darkgrid\")\n\nd1 = load_example_data(\"centered_eight\")\nd2 = load_example_data(\"non_centered_eight\")\nplot_elpd(Dict(\"Centered eight\" => d1, \"Non centered eight\" => d2); xlabels=true)\ngcf()","category":"page"},{"location":"examples/","page":"Examples gallery","title":"Examples gallery","text":"See plot_elpd","category":"page"},{"location":"examples/#Energy-Plot","page":"Examples gallery","title":"Energy Plot","text":"","category":"section"},{"location":"examples/","page":"Examples gallery","title":"Examples gallery","text":"using ArviZPythonPlots, ArviZExampleData\n\nuse_style(\"arviz-darkgrid\")\n\ndata = load_example_data(\"centered_eight\")\nplot_energy(data; figsize=(12, 8))\ngcf()","category":"page"},{"location":"examples/","page":"Examples gallery","title":"Examples gallery","text":"See plot_energy","category":"page"},{"location":"examples/#ESS-Evolution-Plot","page":"Examples gallery","title":"ESS Evolution Plot","text":"","category":"section"},{"location":"examples/","page":"Examples gallery","title":"Examples gallery","text":"using ArviZPythonPlots, ArviZExampleData\n\nuse_style(\"arviz-darkgrid\")\n\nidata = load_example_data(\"radon\")\nplot_ess(idata; var_names=[\"b\"], kind=\"evolution\")\ngcf()","category":"page"},{"location":"examples/","page":"Examples gallery","title":"Examples gallery","text":"See plot_ess","category":"page"},{"location":"examples/#ESS-Local-Plot","page":"Examples gallery","title":"ESS Local Plot","text":"","category":"section"},{"location":"examples/","page":"Examples gallery","title":"Examples gallery","text":"using ArviZPythonPlots, ArviZExampleData\n\nuse_style(\"arviz-darkgrid\")\n\nidata = load_example_data(\"non_centered_eight\")\nplot_ess(idata; var_names=[\"mu\"], kind=\"local\", marker=\"_\", ms=20, mew=2, rug=true)\ngcf()","category":"page"},{"location":"examples/","page":"Examples gallery","title":"Examples gallery","text":"See plot_ess","category":"page"},{"location":"examples/#ESS-Quantile-Plot","page":"Examples gallery","title":"ESS Quantile Plot","text":"","category":"section"},{"location":"examples/","page":"Examples gallery","title":"Examples gallery","text":"using ArviZPythonPlots, ArviZExampleData\n\nuse_style(\"arviz-darkgrid\")\n\nidata = load_example_data(\"radon\")\nplot_ess(idata; var_names=[\"sigma\"], kind=\"quantile\", color=\"C4\")\ngcf()","category":"page"},{"location":"examples/","page":"Examples gallery","title":"Examples gallery","text":"See plot_ess","category":"page"},{"location":"examples/#Forest-Plot","page":"Examples gallery","title":"Forest Plot","text":"","category":"section"},{"location":"examples/","page":"Examples gallery","title":"Examples gallery","text":"using ArviZPythonPlots, ArviZExampleData\n\nuse_style(\"arviz-darkgrid\")\n\ncentered_data = load_example_data(\"centered_eight\")\nnon_centered_data = load_example_data(\"non_centered_eight\")\nplot_forest(\n    [centered_data, non_centered_data];\n    model_names=[\"Centered\", \"Non Centered\"],\n    var_names=[\"mu\"],\n)\ntitle(\"Estimated theta for eight schools model\")\ngcf()","category":"page"},{"location":"examples/","page":"Examples gallery","title":"Examples gallery","text":"See plot_forest","category":"page"},{"location":"examples/#Ridge-Plot","page":"Examples gallery","title":"Ridge Plot","text":"","category":"section"},{"location":"examples/","page":"Examples gallery","title":"Examples gallery","text":"using ArviZPythonPlots, ArviZExampleData\n\nuse_style(\"arviz-darkgrid\")\n\nrugby_data = load_example_data(\"rugby\")\nplot_forest(\n    rugby_data;\n    kind=\"ridgeplot\",\n    var_names=[\"defs\"],\n    linewidth=4,\n    combined=true,\n    ridgeplot_overlap=1.5,\n    colors=\"blue\",\n    figsize=(9, 4),\n)\ntitle(\"Relative defensive strength\\nof Six Nation rugby teams\")\ngcf()","category":"page"},{"location":"examples/","page":"Examples gallery","title":"Examples gallery","text":"See plot_forest","category":"page"},{"location":"examples/#Plot-HDI","page":"Examples gallery","title":"Plot HDI","text":"","category":"section"},{"location":"examples/","page":"Examples gallery","title":"Examples gallery","text":"using Random\nusing ArviZPythonPlots\n\nRandom.seed!(308)\n\nuse_style(\"arviz-darkgrid\")\n\nx_data = randn(100)\ny_data = 2 .+ x_data .* 0.5\ny_data_rep = 0.5 .* randn(200, 100) .+ transpose(y_data)\n\nplot(x_data, y_data; color=\"C6\")\nplot_hdi(x_data, y_data_rep; color=\"k\", plot_kwargs=Dict(\"ls\" => \"--\"))\ngcf()","category":"page"},{"location":"examples/","page":"Examples gallery","title":"Examples gallery","text":"See plot_hdi","category":"page"},{"location":"examples/#Joint-Plot","page":"Examples gallery","title":"Joint Plot","text":"","category":"section"},{"location":"examples/","page":"Examples gallery","title":"Examples gallery","text":"using ArviZPythonPlots, ArviZExampleData\n\nuse_style(\"arviz-darkgrid\")\n\ndata = load_example_data(\"non_centered_eight\")\nplot_pair(\n    data;\n    var_names=[\"theta\"],\n    coords=Dict(\"school\" => [\"Choate\", \"Phillips Andover\"]),\n    kind=\"hexbin\",\n    marginals=true,\n    figsize=(10, 10),\n)\ngcf()","category":"page"},{"location":"examples/","page":"Examples gallery","title":"Examples gallery","text":"See plot_pair","category":"page"},{"location":"examples/#KDE-Plot","page":"Examples gallery","title":"KDE Plot","text":"","category":"section"},{"location":"examples/","page":"Examples gallery","title":"Examples gallery","text":"using ArviZPythonPlots, ArviZExampleData\n\nuse_style(\"arviz-darkgrid\")\n\ndata = load_example_data(\"centered_eight\")\n\n## Combine different posterior draws from different chains\nobs = data.posterior_predictive.obs\nsize_obs = size(obs)\ny_hat = reshape(obs, prod(size_obs[1:2]), size_obs[3:end]...)\n\nplot_kde(\n    y_hat;\n    label=\"Estimated Effect\\n of SAT Prep\",\n    rug=true,\n    plot_kwargs=Dict(\"linewidth\" => 2, \"color\" => \"black\"),\n    rug_kwargs=Dict(\"color\" => \"black\"),\n)\ngcf()","category":"page"},{"location":"examples/","page":"Examples gallery","title":"Examples gallery","text":"See plot_kde","category":"page"},{"location":"examples/#2d-KDE","page":"Examples gallery","title":"2d KDE","text":"","category":"section"},{"location":"examples/","page":"Examples gallery","title":"Examples gallery","text":"using Random\nusing ArviZPythonPlots\n\nRandom.seed!(308)\n\nuse_style(\"arviz-darkgrid\")\n\nplot_kde(rand(100), rand(100))\ngcf()","category":"page"},{"location":"examples/","page":"Examples gallery","title":"Examples gallery","text":"See plot_kde","category":"page"},{"location":"examples/#KDE-Quantiles-Plot","page":"Examples gallery","title":"KDE Quantiles Plot","text":"","category":"section"},{"location":"examples/","page":"Examples gallery","title":"Examples gallery","text":"using Random\nusing Distributions\nusing ArviZPythonPlots\n\nRandom.seed!(308)\n\nuse_style(\"arviz-darkgrid\")\n\ndist = rand(Beta(rand(Uniform(0.5, 10)), 5), 1000)\nplot_kde(dist; quantiles=[0.25, 0.5, 0.75])\ngcf()","category":"page"},{"location":"examples/","page":"Examples gallery","title":"Examples gallery","text":"See plot_kde","category":"page"},{"location":"examples/#Pareto-Shape-Plot","page":"Examples gallery","title":"Pareto Shape Plot","text":"","category":"section"},{"location":"examples/","page":"Examples gallery","title":"Examples gallery","text":"using ArviZ, ArviZPythonPlots, ArviZExampleData\n\nuse_style(\"arviz-darkgrid\")\n\nidata = load_example_data(\"radon\")\nloo_data = loo(idata)\nplot_khat(loo_data; show_bins=true)\ngcf()","category":"page"},{"location":"examples/","page":"Examples gallery","title":"Examples gallery","text":"See loo, plot_khat","category":"page"},{"location":"examples/#LOO-PIT-ECDF-Plot","page":"Examples gallery","title":"LOO-PIT ECDF Plot","text":"","category":"section"},{"location":"examples/","page":"Examples gallery","title":"Examples gallery","text":"using ArviZPythonPlots, ArviZExampleData\n\nuse_style(\"arviz-darkgrid\")\n\nidata = load_example_data(\"radon\")\n\nplot_loo_pit(idata; y=\"y\", ecdf=true, color=\"maroon\")\ngcf()","category":"page"},{"location":"examples/","page":"Examples gallery","title":"Examples gallery","text":"See loo_pit, plot_loo_pit","category":"page"},{"location":"examples/#LOO-PIT-Overlay-Plot","page":"Examples gallery","title":"LOO-PIT Overlay Plot","text":"","category":"section"},{"location":"examples/","page":"Examples gallery","title":"Examples gallery","text":"using ArviZPythonPlots, ArviZExampleData\n\nuse_style(\"arviz-darkgrid\")\n\nidata = load_example_data(\"non_centered_eight\")\nplot_loo_pit(; idata, y=\"obs\", color=\"indigo\")\ngcf()","category":"page"},{"location":"examples/","page":"Examples gallery","title":"Examples gallery","text":"See loo_pit, plot_loo_pit","category":"page"},{"location":"examples/#Quantile-Monte-Carlo-Standard-Error-Plot","page":"Examples gallery","title":"Quantile Monte Carlo Standard Error Plot","text":"","category":"section"},{"location":"examples/","page":"Examples gallery","title":"Examples gallery","text":"using ArviZPythonPlots, ArviZExampleData\n\nuse_style(\"arviz-darkgrid\")\n\ndata = load_example_data(\"centered_eight\")\nplot_mcse(data; var_names=[\"tau\", \"mu\"], rug=true, extra_methods=true)\ngcf()","category":"page"},{"location":"examples/","page":"Examples gallery","title":"Examples gallery","text":"See plot_mcse","category":"page"},{"location":"examples/#Quantile-MCSE-Errobar-Plot","page":"Examples gallery","title":"Quantile MCSE Errobar Plot","text":"","category":"section"},{"location":"examples/","page":"Examples gallery","title":"Examples gallery","text":"using ArviZPythonPlots, ArviZExampleData\n\nuse_style(\"arviz-darkgrid\")\n\ndata = load_example_data(\"radon\")\nplot_mcse(data; var_names=[\"sigma_a\"], color=\"C4\", errorbar=true)\ngcf()","category":"page"},{"location":"examples/","page":"Examples gallery","title":"Examples gallery","text":"See plot_mcse","category":"page"},{"location":"examples/#Pair-Plot","page":"Examples gallery","title":"Pair Plot","text":"","category":"section"},{"location":"examples/","page":"Examples gallery","title":"Examples gallery","text":"using ArviZPythonPlots, ArviZExampleData\n\nuse_style(\"arviz-darkgrid\")\n\ncentered = load_example_data(\"centered_eight\")\ncoords = Dict(\"school\" => [\"Choate\", \"Deerfield\"])\nplot_pair(\n    centered; var_names=[\"theta\", \"mu\", \"tau\"], coords, divergences=true, textsize=22\n)\ngcf()","category":"page"},{"location":"examples/","page":"Examples gallery","title":"Examples gallery","text":"See plot_pair","category":"page"},{"location":"examples/#Hexbin-Pair-Plot","page":"Examples gallery","title":"Hexbin Pair Plot","text":"","category":"section"},{"location":"examples/","page":"Examples gallery","title":"Examples gallery","text":"using ArviZPythonPlots, ArviZExampleData\n\nuse_style(\"arviz-darkgrid\")\n\ncentered = load_example_data(\"centered_eight\")\ncoords = Dict(\"school\" => [\"Choate\", \"Deerfield\"])\nplot_pair(\n    centered;\n    var_names=[\"theta\", \"mu\", \"tau\"],\n    kind=\"hexbin\",\n    coords,\n    colorbar=true,\n    divergences=true,\n)\ngcf()","category":"page"},{"location":"examples/","page":"Examples gallery","title":"Examples gallery","text":"See plot_pair","category":"page"},{"location":"examples/#KDE-Pair-Plot","page":"Examples gallery","title":"KDE Pair Plot","text":"","category":"section"},{"location":"examples/","page":"Examples gallery","title":"Examples gallery","text":"using ArviZPythonPlots, ArviZExampleData\n\nuse_style(\"arviz-darkgrid\")\n\ncentered = load_example_data(\"centered_eight\")\ncoords = Dict(\"school\" => [\"Choate\", \"Deerfield\"])\nplot_pair(\n    centered;\n    var_names=[\"theta\", \"mu\", \"tau\"],\n    kind=\"kde\",\n    coords,\n    divergences=true,\n    textsize=22,\n)\ngcf()","category":"page"},{"location":"examples/","page":"Examples gallery","title":"Examples gallery","text":"See plot_pair","category":"page"},{"location":"examples/#Point-Estimate-Pair-Plot","page":"Examples gallery","title":"Point Estimate Pair Plot","text":"","category":"section"},{"location":"examples/","page":"Examples gallery","title":"Examples gallery","text":"using ArviZPythonPlots, ArviZExampleData\n\nuse_style(\"arviz-darkgrid\")\n\ncentered = load_example_data(\"centered_eight\")\ncoords = Dict(\"school\" => [\"Choate\", \"Deerfield\"])\nplot_pair(\n    centered;\n    var_names=[\"mu\", \"theta\"],\n    kind=[\"scatter\", \"kde\"],\n    kde_kwargs=Dict(\"fill_last\" => false),\n    marginals=true,\n    coords,\n    point_estimate=\"median\",\n    figsize=(10, 8),\n)\ngcf()","category":"page"},{"location":"examples/","page":"Examples gallery","title":"Examples gallery","text":"See plot_pair","category":"page"},{"location":"examples/#Parallel-Plot","page":"Examples gallery","title":"Parallel Plot","text":"","category":"section"},{"location":"examples/","page":"Examples gallery","title":"Examples gallery","text":"using ArviZPythonPlots, ArviZExampleData\n\nuse_style(\"arviz-darkgrid\")\n\ndata = load_example_data(\"centered_eight\")\nax = plot_parallel(data; var_names=[\"theta\", \"tau\", \"mu\"])\nax.set_xticklabels(ax.get_xticklabels(); rotation=70)\ndraw()\ngcf()","category":"page"},{"location":"examples/","page":"Examples gallery","title":"Examples gallery","text":"See plot_parallel","category":"page"},{"location":"examples/#Posterior-Plot","page":"Examples gallery","title":"Posterior Plot","text":"","category":"section"},{"location":"examples/","page":"Examples gallery","title":"Examples gallery","text":"using ArviZPythonPlots, ArviZExampleData\n\nuse_style(\"arviz-darkgrid\")\n\ndata = load_example_data(\"centered_eight\")\ncoords = Dict(\"school\" => [\"Choate\"])\nplot_posterior(data; var_names=[\"mu\", \"theta\"], coords, rope=(-1, 1))\ngcf()","category":"page"},{"location":"examples/","page":"Examples gallery","title":"Examples gallery","text":"See plot_posterior","category":"page"},{"location":"examples/#Posterior-Predictive-Check-Plot","page":"Examples gallery","title":"Posterior Predictive Check Plot","text":"","category":"section"},{"location":"examples/","page":"Examples gallery","title":"Examples gallery","text":"using ArviZPythonPlots, ArviZExampleData\n\nuse_style(\"arviz-darkgrid\")\n\ndata = load_example_data(\"non_centered_eight\")\nplot_ppc(data; data_pairs=Dict(\"obs\" => \"obs\"), alpha=0.03, figsize=(12, 6), textsize=14)\ngcf()","category":"page"},{"location":"examples/","page":"Examples gallery","title":"Examples gallery","text":"See plot_ppc","category":"page"},{"location":"examples/#Posterior-Predictive-Check-Cumulative-Plot","page":"Examples gallery","title":"Posterior Predictive Check Cumulative Plot","text":"","category":"section"},{"location":"examples/","page":"Examples gallery","title":"Examples gallery","text":"using ArviZPythonPlots, ArviZExampleData\n\nuse_style(\"arviz-darkgrid\")\n\ndata = load_example_data(\"non_centered_eight\")\nplot_ppc(data; alpha=0.3, kind=\"cumulative\", figsize=(12, 6), textsize=14)\ngcf()","category":"page"},{"location":"examples/","page":"Examples gallery","title":"Examples gallery","text":"See plot_ppc","category":"page"},{"location":"examples/#Rank-Plot","page":"Examples gallery","title":"Rank Plot","text":"","category":"section"},{"location":"examples/","page":"Examples gallery","title":"Examples gallery","text":"using ArviZPythonPlots, ArviZExampleData\n\nuse_style(\"arviz-darkgrid\")\n\ndata = load_example_data(\"centered_eight\")\nplot_rank(data; var_names=[\"tau\", \"mu\"])\ngcf()","category":"page"},{"location":"examples/","page":"Examples gallery","title":"Examples gallery","text":"See plot_rank","category":"page"},{"location":"examples/#Regression-Plot","page":"Examples gallery","title":"Regression Plot","text":"","category":"section"},{"location":"examples/","page":"Examples gallery","title":"Examples gallery","text":"using ArviZ, ArviZPythonPlots, ArviZExampleData, DimensionalData\n\nuse_style(\"arviz-darkgrid\")\n\ndata = load_example_data(\"regression1d\")\nx = range(0, 1; length=100)\nposterior = data.posterior\nconstant_data = convert_to_dataset((; x); default_dims=())\ny_model = broadcast_dims(muladd, posterior.intercept, posterior.slope, constant_data.x)\nposterior = merge(posterior, (; y_model))\ndata = merge(data, InferenceData(; posterior, constant_data))\nplot_lm(\"y\"; idata=data, x=\"x\", y_model=\"y_model\")\ngcf()","category":"page"},{"location":"examples/","page":"Examples gallery","title":"Examples gallery","text":"See plot_lm","category":"page"},{"location":"examples/#Separation-Plot","page":"Examples gallery","title":"Separation Plot","text":"","category":"section"},{"location":"examples/","page":"Examples gallery","title":"Examples gallery","text":"using ArviZPythonPlots, ArviZExampleData\n\nuse_style(\"arviz-darkgrid\")\n\ndata = load_example_data(\"classification10d\")\nplot_separation(data; y=\"outcome\", y_hat=\"outcome\", figsize=(8, 1))\ngcf()","category":"page"},{"location":"examples/","page":"Examples gallery","title":"Examples gallery","text":"See plot_separation","category":"page"},{"location":"examples/#Trace-Plot","page":"Examples gallery","title":"Trace Plot","text":"","category":"section"},{"location":"examples/","page":"Examples gallery","title":"Examples gallery","text":"using ArviZPythonPlots, ArviZExampleData\n\nuse_style(\"arviz-darkgrid\")\n\ndata = load_example_data(\"non_centered_eight\")\nplot_trace(data; var_names=[\"tau\", \"mu\"])\ngcf()","category":"page"},{"location":"examples/","page":"Examples gallery","title":"Examples gallery","text":"See plot_trace","category":"page"},{"location":"examples/#Violin-Plot","page":"Examples gallery","title":"Violin Plot","text":"","category":"section"},{"location":"examples/","page":"Examples gallery","title":"Examples gallery","text":"using ArviZPythonPlots, ArviZExampleData\n\nuse_style(\"arviz-darkgrid\")\n\ndata = load_example_data(\"non_centered_eight\")\nplot_violin(data; var_names=[\"mu\", \"tau\"])\ngcf()","category":"page"},{"location":"examples/","page":"Examples gallery","title":"Examples gallery","text":"See plot_violin","category":"page"},{"location":"examples/#Styles","page":"Examples gallery","title":"Styles","text":"","category":"section"},{"location":"examples/","page":"Examples gallery","title":"Examples gallery","text":"using ArviZPythonPlots, Distributions, PythonCall\n\nx = range(0, 1; length=100)\ndist = pdf.(Beta(2, 5), x)\n\nstyle_list = [\n    \"default\",\n    [\"default\", \"arviz-colors\"],\n    \"arviz-darkgrid\",\n    \"arviz-whitegrid\",\n    \"arviz-white\",\n    \"arviz-grayscale\",\n    [\"arviz-white\", \"arviz-redish\"],\n    [\"arviz-white\", \"arviz-bluish\"],\n    [\"arviz-white\", \"arviz-orangish\"],\n    [\"arviz-white\", \"arviz-brownish\"],\n    [\"arviz-white\", \"arviz-purplish\"],\n    [\"arviz-white\", \"arviz-cyanish\"],\n    [\"arviz-white\", \"arviz-greenish\"],\n    [\"arviz-white\", \"arviz-royish\"],\n    [\"arviz-white\", \"arviz-viridish\"],\n    [\"arviz-white\", \"arviz-plasmish\"],\n    \"arviz-doc\",\n    \"arviz-docgrid\",\n]\n\nfig = figure(; figsize=(20, 10))\nfor (idx, style) in enumerate(style_list)\n    pywith(pyplot.style.context(style; after_reset=true)) do _\n        ax = fig.add_subplot(5, 4, idx; label=idx)\n        colors = pyplot.rcParams[\"axes.prop_cycle\"].by_key()[\"color\"]\n        for i in 0:(length(colors) - 1)\n            ax.plot(x, dist .- i, \"C$i\"; label=\"C$i\")\n        end\n        ax.set_title(style)\n        ax.set_xlabel(\"x\")\n        ax.set_ylabel(\"f(x)\"; rotation=0, labelpad=15)\n        ax.set_xticklabels([])\n    end\nend\ntight_layout()\ngcf()","category":"page"},{"location":"api/style/#style-api","page":"Plotting styles","title":"Plotting styles","text":"","category":"section"},{"location":"api/style/","page":"Plotting styles","title":"Plotting styles","text":"Pages = [\"style.md\"]","category":"page"},{"location":"api/style/#Reference","page":"Plotting styles","title":"Reference","text":"","category":"section"},{"location":"api/style/","page":"Plotting styles","title":"Plotting styles","text":"Modules = [ArviZPythonPlots]\nPages   = [\"style.jl\"]\nPrivate = false","category":"page"},{"location":"api/style/#ArviZPythonPlots.styles-Tuple{}","page":"Plotting styles","title":"ArviZPythonPlots.styles","text":"styles() -> Vector{String}\n\nGet all available matplotlib styles for use with use_style\n\n\n\n\n\n","category":"method"},{"location":"api/style/#ArviZPythonPlots.use_style-Tuple{Any}","page":"Plotting styles","title":"ArviZPythonPlots.use_style","text":"use_style(style::String)\nuse_style(style::Vector{String})\n\nUse matplotlib style settings from a style specification style.\n\nThe style name of \"default\" is reserved for reverting back to the default style settings.\n\nArviZ-specific styles include [\"arviz-whitegrid\", \"arviz-darkgrid\", \"arviz-colors\", \"arviz-white\", \"arviz-doc\"]. To see all available style specifications, use styles().\n\nIf a Vector of styles is provided, they are applied from first to last.\n\n\n\n\n\n","category":"method"},{"location":"#ArviZPythonPlots.jl","page":"Home","title":"ArviZPythonPlots.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ArviZPythonPlots.jl provides PyPlot-compatible plotting functions for exploratory analysis of Bayesian models using ArviZ.jl. It uses PythonCall.jl to provide an interface for using the plotting functions in Python ArviZ with Julia types. It also re-exports all methods exported by PythonPlot.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For details, see the Example Gallery or the API.","category":"page"},{"location":"#installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install ArviZPythonPlots.jl, we first need to install Python ArviZ. From the Julia REPL, type ] to enter the Pkg REPL mode and run","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add ArviZPythonPlots","category":"page"},{"location":"api/plots/#plots-api","page":"Plotting functions","title":"Plotting functions","text":"","category":"section"},{"location":"api/plots/","page":"Plotting functions","title":"Plotting functions","text":"Pages = [\"plots.md\"]","category":"page"},{"location":"api/plots/#Reference","page":"Plotting functions","title":"Reference","text":"","category":"section"},{"location":"api/plots/","page":"Plotting functions","title":"Plotting functions","text":"Modules = [ArviZPythonPlots]\nPages   = [\"plots.jl\"]\nPrivate = false","category":"page"},{"location":"api/plots/#ArviZPythonPlots.plot_autocorr-Tuple","page":"Plotting functions","title":"ArviZPythonPlots.plot_autocorr","text":"Bar plot of the autocorrelation function (ACF) for a sequence of data.\n\n    The ACF plots are helpful as a convergence diagnostic for posteriors from MCMC\n    samples which display autocorrelation.\n\n    Parameters\n    ----------\n    data : InferenceData\n        Any object that can be converted to an :class:`arviz.InferenceData` object\n        refer to documentation of :func:`arviz.convert_to_dataset` for details\n    var_names : list of str, optional\n        Variables to be plotted. Prefix the variables by ``~`` when you want to exclude\n        them from the plot. See :ref:`this section <common_var_names>` for usage examples.\n    filter_vars : {None, \"like\", \"regex\"}, default None\n        If `None` (default), interpret `var_names` as the real variables names. If \"like\",\n        interpret `var_names` as substrings of the real variables names. If \"regex\",\n        interpret `var_names` as regular expressions on the real variables names. See\n        :ref:`this section <common_filter_vars>` for usage examples.\n    max_lag : int, optional\n        Maximum lag to calculate autocorrelation. By Default, the plot displays the\n        first 100 lag or the total number of draws, whichever is smaller.\n    combined : bool, default False\n        Flag for combining multiple chains into a single chain. If False, chains will be\n        plotted separately.\n    grid : tuple, optional\n        Number of rows and columns. Defaults to None, the rows and columns are\n        automatically inferred. See :ref:`this section <common_grid>` for usage examples.\n    figsize : (float, float), optional\n        Figure size. If None it will be defined automatically.\n        Note this is not used if `ax` is supplied.\n    textsize : float, optional\n        Text size scaling factor for labels, titles and lines. If None it will be autoscaled based\n        on `figsize`.\n    labeller : Labeller, optional\n        Class providing the method ``make_label_vert`` to generate the labels in the plot titles.\n        Read the :ref:`label_guide` for more details and usage examples.\n    ax : 2D array-like of matplotlib_axes or bokeh_figure, optional\n        A 2D array of locations into which to plot the densities. If not supplied, ArviZ will create\n        its own array of plot areas (and return it).\n    backend : {\"matplotlib\", \"bokeh\"}, default \"matplotlib\"\n        Select plotting backend.\n    backend_config : dict, optional\n        Currently specifies the bounds to use for bokeh axes. Defaults to value set in ``rcParams``.\n    backend_kwargs : dict, optional\n        These are kwargs specific to the backend being used, passed to\n        :func:`matplotlib.pyplot.subplots` or :class:`bokeh.plotting.figure`.\n        For additional documentation check the plotting method of the backend.\n    show : bool, optional\n        Call backend show function.\n\n    Returns\n    -------\n    axes : matplotlib_axes or bokeh_figures\n\n    See Also\n    --------\n    autocov : Compute autocovariance estimates for every lag for the input array.\n    autocorr : Compute autocorrelation using FFT for every lag for the input array.\n\n    Examples\n    --------\n    Plot default autocorrelation\n\n    .. plot::\n        :context: close-figs\n\n        >>> import arviz as az\n        >>> data = az.load_arviz_data('centered_eight')\n        >>> az.plot_autocorr(data)\n\n    Plot subset variables by specifying variable name exactly\n\n    .. plot::\n        :context: close-figs\n\n        >>> az.plot_autocorr(data, var_names=['mu', 'tau'] )\n\n\n    Combine chains by variable and select variables by excluding some with partial naming\n\n    .. plot::\n        :context: close-figs\n\n        >>> az.plot_autocorr(data, var_names=['~thet'], filter_vars=\"like\", combined=True)\n\n\n    Specify maximum lag (x axis bound)\n\n    .. plot::\n        :context: close-figs\n\n        >>> az.plot_autocorr(data, var_names=['mu', 'tau'], max_lag=200, combined=True)\n    \n\n\n\n\n\n\n","category":"method"},{"location":"api/plots/#ArviZPythonPlots.plot_bf-Tuple","page":"Plotting functions","title":"ArviZPythonPlots.plot_bf","text":"Approximated Bayes Factor for comparing hypothesis of two nested models.\n\n    The Bayes factor is estimated by comparing a model (H1) against a model in which the\n    parameter of interest has been restricted to be a point-null (H0). This computation\n    assumes the models are nested and thus H0 is a special case of H1.\n\n    Notes\n    -----\n    The bayes Factor is approximated pproximated as the Savage-Dickey density ratio\n    algorithm presented in [1]_.\n\n    Parameters\n    -----------\n    idata : InferenceData\n        Any object that can be converted to an :class:`arviz.InferenceData` object\n        Refer to documentation of :func:`arviz.convert_to_dataset` for details.\n    var_name : str, optional\n        Name of variable we want to test.\n    prior : numpy.array, optional\n        In case we want to use different prior, for example for sensitivity analysis.\n    ref_val : int, default 0\n        Point-null for Bayes factor estimation.\n    xlim :  tuple, optional\n        Set the x limits, which might be used for visualization purposes.\n    colors : tuple, default ('C0', 'C1')\n        Tuple of valid Matplotlib colors. First element for the prior, second for the posterior.\n    figsize : (float, float), optional\n        Figure size. If `None` it will be defined automatically.\n    textsize: float, optional\n        Text size scaling factor for labels, titles and lines. If `None` it will be autoscaled based\n        on `figsize`.\n    plot_kwargs : dicts, optional\n        Additional keywords passed to :func:`matplotlib.pyplot.plot`.\n    hist_kwargs : dicts, optional\n        Additional keywords passed to :func:`arviz.plot_dist`. Only works for discrete variables.\n    ax : axes, optional\n        :class:`matplotlib.axes.Axes` or :class:`bokeh.plotting.Figure`.\n    backend :{\"matplotlib\", \"bokeh\"}, default \"matplotlib\"\n        Select plotting backend.\n    backend_kwargs : dict, optional\n        These are kwargs specific to the backend being used, passed to\n        :func:`matplotlib.pyplot.subplots` or :class:`bokeh.plotting.figure`.\n        For additional documentation check the plotting method of the backend.\n    show : bool, optional\n        Call backend show function.\n\n    Returns\n    -------\n    dict : A dictionary with BF10 (Bayes Factor 10 (H1/H0 ratio), and BF01 (H0/H1 ratio).\n    axes : matplotlib_axes or bokeh_figure\n\n    References\n    ----------\n    .. [1] Heck, D., 2019. A caveat on the avage-Dickey density ratio:\n    The case of computing Bayes factors for regression parameters.\n\n    Examples\n    --------\n    Moderate evidence indicating that the parameter \"a\" is different from zero.\n\n    .. plot::\n        :context: close-figs\n\n        >>> import numpy as np\n        >>> import arviz as az\n        >>> idata = az.from_dict(posterior={\"a\":np.random.normal(1, 0.5, 5000)},\n        ...     prior={\"a\":np.random.normal(0, 1, 5000)})\n        >>> az.plot_bf(idata, var_name=\"a\", ref_val=0)\n    \n\n\n\n\n\n\n","category":"method"},{"location":"api/plots/#ArviZPythonPlots.plot_bpv-Tuple","page":"Plotting functions","title":"ArviZPythonPlots.plot_bpv","text":"Plot Bayesian p-value for observed data and Posterior/Prior predictive.\n\n    Parameters\n    ----------\n    data : InferenceData\n        :class:`arviz.InferenceData` object containing the observed and\n        posterior/prior predictive data.\n    kind : {\"u_value\", \"p_value\", \"t_stat\"}, default \"u_value\"\n        Specify the kind of plot:\n\n        * The ``kind=\"p_value\"`` computes :math:`p := p(y* \\leq y | y)`.\n          This is the probability of the data y being larger or equal than the predicted data y*.\n          The ideal value is 0.5 (half the predictions below and half above the data).\n        * The ``kind=\"u_value\"`` argument computes :math:`p_i := p(y_i* \\leq y_i | y)`.\n          i.e. like a p_value but per observation :math:`y_i`. This is also known as marginal\n          p_value. The ideal distribution is uniform. This is similar to the LOO-PIT\n          calculation/plot, the difference is than in LOO-pit plot we compute\n          :math:`pi = p(y_i* r \\leq y_i | y_{-i} )`, where :math:`y_{-i}`,\n          is all other data except :math:`y_i`.\n        * The ``kind=\"t_stat\"`` argument computes :math:`:= p(T(y)* \\leq T(y) | y)`\n          where T is any test statistic. See ``t_stat`` argument below for details\n          of available options.\n\n    t_stat : str, float, or callable, default \"median\"\n        Test statistics to compute from the observations and predictive distributions.\n        Allowed strings are “mean”, “median” or “std”. Alternative a quantile can be passed\n        as a float (or str) in the interval (0, 1). Finally a user defined function is also\n        acepted, see examples section for details.\n    bpv : bool, default True\n        If True add the Bayesian p_value to the legend when ``kind = t_stat``.\n    plot_mean : bool, default True\n        Whether or not to plot the mean test statistic.\n    reference : {\"analytical\", \"samples\", None}, default \"analytical\"\n        How to compute the distributions used as reference for ``kind=u_values``\n        or ``kind=p_values``. Use `None` to not plot any reference.\n    mse : bool, default False\n        Show scaled mean square error between uniform distribution and marginal p_value\n        distribution.\n    n_ref : int, default 100\n        Number of reference distributions to sample when ``reference=samples``.\n    hdi_prob : float, optional\n        Probability for the highest density interval for the analytical reference distribution when\n        ``kind=u_values``. Should be in the interval (0, 1]. Defaults to the\n        rcParam ``stats.hdi_prob``. See :ref:`this section <common_hdi_prob>` for usage examples.\n    color : str, optional\n        Matplotlib color\n    grid : tuple, optional\n        Number of rows and columns. By default, the rows and columns are\n        automatically inferred. See :ref:`this section <common_grid>` for usage examples.\n    figsize : (float, float), optional\n        Figure size. If None it will be defined automatically.\n    textsize : float, optional\n        Text size scaling factor for labels, titles and lines. If None it will be autoscaled based\n        on `figsize`.\n    data_pairs : dict, optional\n        Dictionary containing relations between observed data and posterior/prior predictive data.\n        Dictionary structure:\n\n        - key = data var_name\n        - value = posterior/prior predictive var_name\n\n        For example, ``data_pairs = {'y' : 'y_hat'}``\n        If None, it will assume that the observed data and the posterior/prior\n        predictive data have the same variable name.\n    Labeller : Labeller, optional\n        Class providing the method ``make_pp_label`` to generate the labels in the plot titles.\n        Read the :ref:`label_guide` for more details and usage examples.\n    var_names : list of str, optional\n        Variables to be plotted. If `None` all variable are plotted. Prefix the variables by ``~``\n        when you want to exclude them from the plot. See the :ref:`this section <common_var_names>`\n        for usage examples. See :ref:`this section <common_var_names>` for usage examples.\n    filter_vars : {None, \"like\", \"regex\"}, default None\n        If `None` (default), interpret `var_names` as the real variables names. If \"like\",\n        interpret `var_names` as substrings of the real variables names. If \"regex\",\n        interpret `var_names` as regular expressions on the real variables names. See\n        :ref:`this section <common_filter_vars>` for usage examples.\n    coords : dict, optional\n        Dictionary mapping dimensions to selected coordinates to be plotted.\n        Dimensions without a mapping specified will include all coordinates for\n        that dimension. Defaults to including all coordinates for all\n        dimensions if None. See :ref:`this section <common_coords>` for usage examples.\n    flatten : list, optional\n        List of dimensions to flatten in observed_data. Only flattens across the coordinates\n        specified in the coords argument. Defaults to flattening all of the dimensions.\n    flatten_pp : list, optional\n        List of dimensions to flatten in posterior_predictive/prior_predictive. Only flattens\n        across the coordinates specified in the coords argument. Defaults to flattening all\n        of the dimensions. Dimensions should match flatten excluding dimensions for data_pairs\n        parameters. If `flatten` is defined and `flatten_pp` is None, then ``flatten_pp=flatten``.\n    legend : bool, default True\n        Add legend to figure.\n    ax : 2D array-like of matplotlib_axes or bokeh_figure, optional\n        A 2D array of locations into which to plot the densities. If not supplied, ArviZ will create\n        its own array of plot areas (and return it).\n    backend : str, optional\n        Select plotting backend {\"matplotlib\", \"bokeh\"}. Default \"matplotlib\".\n    plot_ref_kwargs :  dict, optional\n        Extra keyword arguments to control how reference is represented.\n        Passed to :meth:`matplotlib.axes.Axes.plot` or\n        :meth:`matplotlib.axes.Axes.axhspan` (when ``kind=u_value``\n        and ``reference=analytical``).\n    backend_kwargs : bool, optional\n        These are kwargs specific to the backend being used, passed to\n        :func:`matplotlib.pyplot.subplots` or :class:`bokeh.plotting.figure`.\n        For additional documentation check the plotting method of the backend.\n    group : {\"posterior\", \"prior\"}, default \"posterior\"\n        Specifies which InferenceData group should be plotted. If \"posterior\", then the values\n        in `posterior_predictive` group are compared to the ones in `observed_data`, if \"prior\" then\n        the same comparison happens, but with the values in `prior_predictive` group.\n    show : bool, optional\n        Call backend show function.\n\n    Returns\n    -------\n    axes : 2D ndarray of matplotlib_axes or bokeh_figure\n\n    See Also\n    --------\n    plot_ppc : Plot for posterior/prior predictive checks.\n    plot_loo_pit : Plot Leave-One-Out probability integral transformation (PIT) predictive checks.\n    plot_dist_comparison : Plot to compare fitted and unfitted distributions.\n\n    References\n    ----------\n    * Gelman et al. (2013) see http://www.stat.columbia.edu/~gelman/book/ pages 151-153 for details\n\n    Examples\n    --------\n    Plot Bayesian p_values.\n\n    .. plot::\n        :context: close-figs\n\n        >>> import arviz as az\n        >>> data = az.load_arviz_data(\"regression1d\")\n        >>> az.plot_bpv(data, kind=\"p_value\")\n\n    Plot custom test statistic comparison.\n\n    .. plot::\n        :context: close-figs\n\n        >>> import arviz as az\n        >>> data = az.load_arviz_data(\"regression1d\")\n        >>> az.plot_bpv(data, kind=\"t_stat\", t_stat=lambda x:np.percentile(x, q=50, axis=-1))\n    \n\n\n\n\n\n\n","category":"method"},{"location":"api/plots/#ArviZPythonPlots.plot_compare-Tuple","page":"Plotting functions","title":"ArviZPythonPlots.plot_compare","text":"Summary plot for model comparison.\n\n    Models are compared based on their expected log pointwise predictive density (ELPD).\n    This plot is in the style of the one used in [2]_. Chapter 6 in the first edition\n    or 7 in the second.\n\n    Notes\n    -----\n    The ELPD is estimated either by Pareto smoothed importance sampling leave-one-out\n    cross-validation (LOO) or using the widely applicable information criterion (WAIC).\n    We recommend LOO in line with the work presented by [1]_.\n\n    Parameters\n    ----------\n    comp_df : pandas.DataFrame\n        Result of the :func:`arviz.compare` method.\n    insample_dev : bool, default False\n        Plot in-sample ELPD, that is the value of the information criteria without the\n        penalization given by the effective number of parameters (p_loo or p_waic).\n    plot_standard_error : bool, default True\n        Plot the standard error of the ELPD.\n    plot_ic_diff : bool, default True\n        Plot standard error of the difference in ELPD between each model\n        and the top-ranked model.\n    order_by_rank : bool, default True\n        If True ensure the best model is used as reference.\n    legend : bool, default True\n        Add legend to figure.\n    figsize : (float, float), optional\n        If `None`, size is (6, num of models) inches.\n    title : bool, default True\n        Show a tittle with a description of how to interpret the plot.\n    textsize : float, optional\n        Text size scaling factor for labels, titles and lines. If `None` it will be autoscaled based\n        on `figsize`.\n    labeller : Labeller, optional\n        Class providing the method ``make_label_vert`` to generate the labels in the plot titles.\n        Read the :ref:`label_guide` for more details and usage examples.\n    plot_kwargs : dict, optional\n        Optional arguments for plot elements. Currently accepts 'color_ic',\n        'marker_ic', 'color_insample_dev', 'marker_insample_dev', 'color_dse',\n        'marker_dse', 'ls_min_ic' 'color_ls_min_ic',  'fontsize'\n    ax : matplotlib_axes or bokeh_figure, optional\n        Matplotlib axes or bokeh figure.\n    backend : {\"matplotlib\", \"bokeh\"}, default \"matplotlib\"\n        Select plotting backend.\n    backend_kwargs : bool, optional\n        These are kwargs specific to the backend being used, passed to\n        :func:`matplotlib.pyplot.subplots` or :class:`bokeh.plotting.figure`.\n        For additional documentation check the plotting method of the backend.\n    show : bool, optional\n        Call backend show function.\n\n    Returns\n    -------\n    axes : matplotlib_axes or bokeh_figure\n\n    See Also\n    --------\n    plot_elpd : Plot pointwise elpd differences between two or more models.\n    compare : Compare models based on PSIS-LOO loo or WAIC waic cross-validation.\n    loo : Compute Pareto-smoothed importance sampling leave-one-out cross-validation (PSIS-LOO-CV).\n    waic : Compute the widely applicable information criterion.\n\n    References\n    ----------\n    .. [1] Vehtari et al. (2016). Practical Bayesian model evaluation using leave-one-out\n    cross-validation and WAIC https://arxiv.org/abs/1507.04544\n\n    .. [2] McElreath R. (2022). Statistical Rethinking A Bayesian Course with Examples in\n    R and Stan, Second edition, CRC Press.\n\n    Examples\n    --------\n    Show default compare plot\n\n    .. plot::\n        :context: close-figs\n\n        >>> import arviz as az\n        >>> model_compare = az.compare({'Centered 8 schools': az.load_arviz_data('centered_eight'),\n        >>>                  'Non-centered 8 schools': az.load_arviz_data('non_centered_eight')})\n        >>> az.plot_compare(model_compare)\n\n    Include the in-sample ELDP\n\n    .. plot::\n        :context: close-figs\n\n        >>> az.plot_compare(model_compare, insample_dev=True)\n\n    \n\n\n\n\n\n\n","category":"method"},{"location":"api/plots/#ArviZPythonPlots.plot_density-Tuple","page":"Plotting functions","title":"ArviZPythonPlots.plot_density","text":"Generate KDE plots for continuous variables and histograms for discrete ones.\n\n    Plots are truncated at their 100*(1-alpha)% highest density intervals. Plots are grouped per\n    variable and colors assigned to models.\n\n    Parameters\n    ----------\n    data : InferenceData or iterable of InferenceData\n        Any object that can be converted to an :class:`arviz.InferenceData` object, or an Iterator\n        returning a sequence of such objects.\n        Refer to documentation of :func:`arviz.convert_to_dataset` for details.\n    group : {\"posterior\", \"prior\"}, default \"posterior\"\n        Specifies which InferenceData group should be plotted. If \"posterior\", then the values\n        in `posterior_predictive` group are compared to the ones in `observed_data`, if \"prior\" then\n        the same comparison happens, but with the values in `prior_predictive` group.\n    data_labels : list of str, default None\n        List with names for the datasets passed as \"data.\" Useful when plotting more than one\n        dataset.  Must be the same shape as the data parameter.\n    var_names : list of str, optional\n        List of variables to plot. If multiple datasets are supplied and `var_names` is not None,\n        will print the same set of variables for each dataset. Defaults to None, which results in\n        all the variables being plotted.\n    filter_vars : {None, \"like\", \"regex\"}, default None\n        If `None` (default), interpret `var_names` as the real variables names. If \"like\",\n        interpret `var_names` as substrings of the real variables names. If \"regex\",\n        interpret `var_names` as regular expressions on the real variables names. See\n        :ref:`this section <common_filter_vars>` for usage examples.\n    combine_dims : set_like of str, optional\n        List of dimensions to reduce. Defaults to reducing only the \"chain\" and \"draw\" dimensions.\n        See :ref:`this section <common_combine_dims>` for usage examples.\n    transform : callable\n        Function to transform data (defaults to `None` i.e. the identity function).\n    hdi_prob : float, default 0.94\n        Probability for the highest density interval. Should be in the interval (0, 1].\n        See :ref:`this section <common_hdi_prob>` for usage examples.\n    point_estimate : str, optional\n        Plot point estimate per variable. Values should be 'mean', 'median', 'mode' or None.\n        Defaults to 'auto' i.e. it falls back to default set in ``rcParams``.\n    colors : str or list of str, optional\n        List with valid matplotlib colors, one color per model. Alternative a string can be passed.\n        If the string is `cycle`, it will automatically choose a color per model from matplotlib's\n        cycle. If a single color is passed, e.g. 'k', 'C2' or 'red' this color will be used for all\n        models. Defaults to `cycle`.\n    outline : bool, default True\n        Use a line to draw KDEs and histograms.\n    hdi_markers : str\n        A valid `matplotlib.markers` like 'v', used to indicate the limits of the highest density\n        interval. Defaults to empty string (no marker).\n    shade : float, default 0\n        Alpha blending value for the shaded area under the curve, between 0 (no shade) and 1\n        (opaque).\n    bw : float or str, optional\n        If numeric, indicates the bandwidth and must be positive.\n        If str, indicates the method to estimate the bandwidth and must be\n        one of \"scott\", \"silverman\", \"isj\" or \"experimental\" when `circular` is False\n        and \"taylor\" (for now) when `circular` is True.\n        Defaults to \"default\" which means \"experimental\" when variable is not circular\n        and \"taylor\" when it is.\n    circular : bool, default False\n        If True, it interprets the values passed are from a circular variable measured in radians\n        and a circular KDE is used. Only valid for 1D KDE.\n    grid : tuple, optional\n        Number of rows and columns. Defaults to ``None``, the rows and columns are\n        automatically inferred. See :ref:`this section <common_grid>` for usage examples.\n    figsize : (float, float), optional\n        Figure size. If `None` it will be defined automatically.\n    textsize : float, optional\n        Text size scaling factor for labels, titles and lines. If `None` it will be autoscaled based\n        on `figsize`.\n    labeller : Labeller, optional\n        Class providing the method ``make_label_vert`` to generate the labels in the plot titles.\n        Read the :ref:`label_guide` for more details and usage examples.\n    ax : 2D array-like of matplotlib_axes or bokeh_figure, optional\n        A 2D array of locations into which to plot the densities. If not supplied, ArviZ will create\n        its own array of plot areas (and return it).\n    backend : {\"matplotlib\", \"bokeh\"}, default \"matplotlib\"\n        Select plotting backend.\n    backend_kwargs : dict, optional\n        These are kwargs specific to the backend being used, passed to\n        :func:`matplotlib.pyplot.subplots` or :class:`bokeh.plotting.figure`.\n        For additional documentation check the plotting method of the backend.\n    show : bool, optional\n        Call backend show function.\n\n    Returns\n    -------\n    axes : 2D ndarray of matplotlib_axes or bokeh_figure\n\n    See Also\n    --------\n    plot_dist : Plot distribution as histogram or kernel density estimates.\n    plot_posterior : Plot Posterior densities in the style of John K. Kruschke's book.\n\n    Examples\n    --------\n    Plot default density plot\n\n    .. plot::\n        :context: close-figs\n\n        >>> import arviz as az\n        >>> centered = az.load_arviz_data('centered_eight')\n        >>> non_centered = az.load_arviz_data('non_centered_eight')\n        >>> az.plot_density([centered, non_centered])\n\n    Plot variables in a 4x5 grid\n\n    .. plot::\n        :context: close-figs\n\n        >>> az.plot_density([centered, non_centered], grid=(4, 5))\n\n    Plot subset variables by specifying variable name exactly\n\n    .. plot::\n        :context: close-figs\n\n        >>> az.plot_density([centered, non_centered], var_names=[\"mu\"])\n\n    Plot a specific `az.InferenceData` group\n\n    .. plot::\n        :context: close-figs\n\n        >>> az.plot_density([centered, non_centered], var_names=[\"mu\"], group=\"prior\")\n\n    Specify highest density interval\n\n    .. plot::\n        :context: close-figs\n\n        >>> az.plot_density([centered, non_centered], var_names=[\"mu\"], hdi_prob=.5)\n\n    Shade plots and/or remove outlines\n\n    .. plot::\n        :context: close-figs\n\n        >>> az.plot_density([centered, non_centered], var_names=[\"mu\"], outline=False, shade=.8)\n\n    Specify binwidth for kernel density estimation\n\n    .. plot::\n        :context: close-figs\n\n        >>> az.plot_density([centered, non_centered], var_names=[\"mu\"], bw=.9)\n    \n\n\n\n\n\n\n","category":"method"},{"location":"api/plots/#ArviZPythonPlots.plot_dist-Tuple","page":"Plotting functions","title":"ArviZPythonPlots.plot_dist","text":"Plot distribution as histogram or kernel density estimates.\n\n    By default continuous variables are plotted using KDEs and discrete ones using histograms\n\n    Parameters\n    ----------\n    values : array-like\n        Values to plot from an unknown continuous or discrete distribution.\n    values2 : array-like, optional\n        Values to plot. If present, a 2D KDE or a hexbin will be estimated.\n    color : string\n        valid matplotlib color.\n    kind : string, default \"auto\"\n        By default (\"auto\") continuous variables will use the kind defined by rcParam\n        ``plot.density_kind`` and discrete ones will use histograms.\n        To override this use \"hist\" to plot histograms and \"kde\" for KDEs.\n    cumulative : bool, default False\n        If true plot the estimated cumulative distribution function. Defaults to False.\n        Ignored for 2D KDE.\n    label : string\n        Text to include as part of the legend.\n    rotated : bool, default False\n        Whether to rotate the 1D KDE plot 90 degrees.\n    rug : bool, default False\n        Add a `rug plot <https://en.wikipedia.org/wiki/Rug_plot>`_ for a specific subset\n        of values. Ignored for 2D KDE.\n    bw : float or str, optional\n        If numeric, indicates the bandwidth and must be positive.\n        If str, indicates the method to estimate the bandwidth and must be\n        one of \"scott\", \"silverman\", \"isj\" or \"experimental\" when ``is_circular`` is False\n        and \"taylor\" (for now) when ``is_circular`` is True.\n        Defaults to \"experimental\" when variable is not circular and \"taylor\" when it is.\n    quantiles : list, optional\n        Quantiles in ascending order used to segment the KDE. Use [.25, .5, .75] for quartiles.\n    contour : bool, default True\n        If True plot the 2D KDE using contours, otherwise plot a smooth 2D KDE.\n    fill_last : bool, default True\n        If True fill the last contour of the 2D KDE plot.\n    figsize : (float, float), optional\n        Figure size. If `None` it will be defined automatically.\n    textsize : float, optional\n        Text size scaling factor for labels, titles and lines. If `None` it will be autoscaled based\n        on `figsize`. Not implemented for bokeh backend.\n    plot_kwargs : dict\n        Keywords passed to the pdf line of a 1D KDE. Passed to :func:`arviz.plot_kde` as\n        ``plot_kwargs``.\n    fill_kwargs : dict\n        Keywords passed to the fill under the line (use fill_kwargs={'alpha': 0} to disable fill).\n        Ignored for 2D KDE. Passed to :func:`arviz.plot_kde` as ``fill_kwargs``.\n    rug_kwargs : dict\n        Keywords passed to the rug plot. Ignored if ``rug=False`` or for 2D KDE\n        Use ``space`` keyword (float) to control the position of the rugplot.\n        The larger this number the lower the rugplot. Passed to\n        :func:`arviz.plot_kde` as ``rug_kwargs``.\n    contour_kwargs : dict\n        Keywords passed to the contourplot. Ignored for 1D KDE.\n    contourf_kwargs : dict\n        Keywords passed to :meth:`matplotlib.axes.Axes.contourf`. Ignored for 1D KDE.\n    pcolormesh_kwargs : dict\n        Keywords passed to :meth:`matplotlib.axes.Axes.pcolormesh`. Ignored for 1D KDE.\n    hist_kwargs : dict\n        Keyword arguments used to customize the histogram. Ignored when plotting a KDE.\n        They are passed to :meth:`matplotlib.axes.Axes.hist` if using matplotlib,\n        or to :meth:`bokeh.plotting.figure.quad` if using bokeh. In bokeh case,\n        the following extra keywords are also supported:\n\n        * ``color``: replaces the ``fill_color`` and ``line_color`` of the ``quad`` method\n        * ``bins``: taken from ``hist_kwargs`` and passed to :func:`numpy.histogram` instead\n        * ``density``: normalize histogram to represent a probability density function,\n          Defaults to ``True``\n\n        * ``cumulative``: plot the cumulative counts. Defaults to ``False``.\n\n    is_circular : {False, True, \"radians\", \"degrees\"}, default False\n        Select input type {\"radians\", \"degrees\"} for circular histogram or KDE plot. If True,\n        default input type is \"radians\". When this argument is present, it interprets the\n        values passed are from a circular variable measured in radians and a circular KDE is\n        used. Inputs in \"degrees\" will undergo an internal conversion to radians. Only valid\n        for 1D KDE.\n    ax : matplotlib_axes or bokeh_figure, optional\n        Matplotlib or bokeh targets on which to plot. If not supplied, Arviz will create\n        its own plot area (and return it).\n    backend : {\"matplotlib\", \"bokeh\"}, default \"matplotlib\"\n        Select plotting backend.\n    backend_kwargs :dict, optional\n        These are kwargs specific to the backend being used, passed to\n        :func:`matplotlib.pyplot.subplots` or :class:`bokeh.plotting.figure`.\n        For additional documentation check the plotting method of the backend.\n    show : bool, optional\n        Call backend show function.\n\n    Returns\n    -------\n    axes : matplotlib axes or bokeh figure\n\n    See Also\n    --------\n    plot_posterior : Plot Posterior densities in the style of John K. Kruschke's book.\n    plot_density : Generate KDE plots for continuous variables and histograms for discrete ones.\n    plot_kde : 1D or 2D KDE plot taking into account boundary conditions.\n\n    Examples\n    --------\n    Plot an integer distribution\n\n    .. plot::\n        :context: close-figs\n\n        >>> import numpy as np\n        >>> import arviz as az\n        >>> a = np.random.poisson(4, 1000)\n        >>> az.plot_dist(a)\n\n    Plot a continuous distribution\n\n    .. plot::\n        :context: close-figs\n\n        >>> b = np.random.normal(0, 1, 1000)\n        >>> az.plot_dist(b)\n\n    Add a rug under the Gaussian distribution\n\n    .. plot::\n        :context: close-figs\n\n        >>> az.plot_dist(b, rug=True)\n\n    Segment into quantiles\n\n    .. plot::\n        :context: close-figs\n\n        >>> az.plot_dist(b, rug=True, quantiles=[.25, .5, .75])\n\n    Plot as the cumulative distribution\n\n    .. plot::\n        :context: close-figs\n\n        >>> az.plot_dist(b, rug=True, quantiles=[.25, .5, .75], cumulative=True)\n    \n\n\n\n\n\n\n","category":"method"},{"location":"api/plots/#ArviZPythonPlots.plot_dist_comparison-Tuple","page":"Plotting functions","title":"ArviZPythonPlots.plot_dist_comparison","text":"Plot to compare fitted and unfitted distributions.\n\n    The resulting plots will show the compared distributions both on\n    separate axes (particularly useful when one of them is substantially tighter\n    than another), and plotted together, displaying a grid of three plots per\n    distribution.\n\n    Parameters\n    ----------\n    data : InferenceData\n        Any object that can be converted to an :class:`arviz.InferenceData` object\n        containing the posterior/prior data. Refer to documentation of\n        :func:`arviz.convert_to_dataset` for details.\n    kind : {\"latent\", \"observed\"}, default \"latent\"\n        kind of plot to display The \"latent\" option includes {\"prior\", \"posterior\"},\n        and the \"observed\" option includes\n        {\"observed_data\", \"prior_predictive\", \"posterior_predictive\"}.\n    figsize : (float, float), optional\n        Figure size. If ``None`` it will be defined automatically.\n    textsize : float\n        Text size scaling factor for labels, titles and lines. If ``None`` it will be\n        autoscaled based on `figsize`.\n    var_names : str, list, list of lists, optional\n        if str, plot the variable. if list, plot all the variables in list\n        of all groups. if list of lists, plot the vars of groups in respective lists.\n        See :ref:`this section <common_var_names>` for usage examples.\n    coords : dict\n        Dictionary mapping dimensions to selected coordinates to be plotted.\n        Dimensions without a mapping specified will include all coordinates for\n        that dimension. See :ref:`this section <common_coords>` for usage examples.\n    combine_dims : set_like of str, optional\n        List of dimensions to reduce. Defaults to reducing only the \"chain\" and \"draw\" dimensions.\n        See :ref:`this section <common_combine_dims>` for usage examples.\n    transform : callable\n        Function to transform data (defaults to `None` i.e. the identity function).\n    legend : bool\n        Add legend to figure. By default True.\n    labeller : Labeller, optional\n        Class providing the method ``make_pp_label`` to generate the labels in the plot titles.\n        Read the :ref:`label_guide` for more details and usage examples.\n    ax : (nvars, 3) array-like of matplotlib_axes, optional\n        Matplotlib axes: The ax argument should have shape (nvars, 3), where the\n        last column is for the combined before/after plots and columns 0 and 1 are\n        for the before and after plots, respectively.\n    prior_kwargs : dicts, optional\n        Additional keywords passed to :func:`arviz.plot_dist` for prior/predictive groups.\n    posterior_kwargs : dicts, optional\n        Additional keywords passed to :func:`arviz.plot_dist` for posterior/predictive groups.\n    observed_kwargs : dicts, optional\n        Additional keywords passed to :func:`arviz.plot_dist` for observed_data group.\n    backend : {\"matplotlib\", \"bokeh\"}, default \"matplotlib\"\n        Select plotting backend.\n    backend_kwargs : dict, optional\n        These are kwargs specific to the backend being used, passed to\n        :func:`matplotlib.pyplot.subplots` or :class:`bokeh.plotting.figure`.\n        For additional documentation check the plotting method of the backend.\n    show : bool, optional\n        Call backend show function.\n\n    Returns\n    -------\n    axes : 2D ndarray of matplotlib_axes\n        Returned object will have shape (nvars, 3),\n        where the last column is the combined plot and the first columns are the single plots.\n\n    See Also\n    --------\n    plot_bpv : Plot Bayesian p-value for observed data and Posterior/Prior predictive.\n\n    Examples\n    --------\n    Plot the prior/posterior plot for specified vars and coords.\n\n    .. plot::\n        :context: close-figs\n\n        >>> import arviz as az\n        >>> data = az.load_arviz_data('rugby')\n        >>> az.plot_dist_comparison(data, var_names=[\"defs\"], coords={\"team\" : [\"Italy\"]})\n\n    \n\n\n\n\n\n\n","category":"method"},{"location":"api/plots/#ArviZPythonPlots.plot_dot-Tuple","page":"Plotting functions","title":"ArviZPythonPlots.plot_dot","text":"Plot distribution as dot plot or quantile dot plot.\n\n    This function uses the Wilkinson's Algorithm [1]_ to allot dots to bins.\n    The quantile dot plots was inspired from [2]_.\n\n    Parameters\n    ----------\n    values : array-like\n        Values to plot from an unknown continuous or discrete distribution.\n    binwidth : float, optional\n        Width of the bin for drawing the dot plot.\n    dotsize : float, default 1\n        The size of the dots relative to the bin width. The default makes dots be\n        just about as wide as the bin width.\n    stackratio : float, default 1\n        The distance between the center of the dots in the same stack relative to the bin height.\n        The default makes dots in the same stack just touch each other.\n    point_interval : bool, default False\n        Plots the point interval. Uses ``hdi_prob`` to plot the HDI interval\n    point_estimate : str, optional\n        Plot point estimate per variable. Values should be ``mean``, ``median``, ``mode`` or None.\n        Defaults to ``auto`` i.e. it falls back to default set in rcParams.\n    dotcolor : string, optional\n        The color of the dots. Should be a valid matplotlib color.\n    intervalcolor : string, optional\n        The color of the interval. Should be a valid matplotlib color.\n    linewidth : int, default None\n        Line width throughout. If None it will be autoscaled based on `figsize`.\n    markersize : int, default None\n        Markersize throughout. If None it will be autoscaled based on `figsize`.\n    markercolor : string, optional\n        The color of the marker when plot_interval is True. Should be a valid matplotlib color.\n    marker : string, default \"o\"\n        The shape of the marker. Valid for matplotlib backend.\n    hdi_prob : float, optional\n        Valid only when point_interval is True. Plots HDI for chosen percentage of density.\n        Defaults to ``stats.hdi_prob`` rcParam. See :ref:`this section <common_hdi_prob>`\n        for usage examples.\n    rotated : bool, default False\n        Whether to rotate the dot plot by 90 degrees.\n    nquantiles : int, default 50\n        Number of quantiles to plot, used for quantile dot plots.\n    quartiles : bool, default True\n        If True then the quartile interval will be plotted with the HDI.\n    figsize : (float,float), optional\n        Figure size. If ``None`` it will be defined automatically.\n    plot_kwargs : dict, optional\n        Keywords passed for customizing the dots. Passed to :class:`mpl:matplotlib.patches.Circle`\n        in matplotlib and :meth:`bokeh.plotting.figure.circle` in bokeh.\n    backend :{\"matplotlib\", \"bokeh\"}, default \"matplotlib\"\n        Select plotting backend.\n    ax : axes, optional\n        Matplotlib_axes or bokeh_figure.\n    show : bool, optional\n        Call backend show function.\n    backend_kwargs : dict, optional\n        These are kwargs specific to the backend being used, passed to\n        :func:`matplotlib.pyplot.subplots` or :class:`bokeh.plotting.figure`.\n        For additional documentation check the plotting method of the backend.\n\n    Returns\n    -------\n    axes : matplotlib_axes or bokeh_figure\n\n    See Also\n    --------\n    plot_dist : Plot distribution as histogram or kernel density estimates.\n\n    References\n    ----------\n    .. [1] Leland Wilkinson (1999) Dot Plots, The American Statistician, 53:3, 276-281,\n        DOI: 10.1080/00031305.1999.10474474\n    .. [2] Matthew Kay, Tara Kola, Jessica R. Hullman,\n        and Sean A. Munson. 2016. When (ish) is My Bus? User-centered Visualizations of Uncertainty\n        in Everyday, Mobile Predictive Systems. DOI:https://doi.org/10.1145/2858036.2858558\n\n    Examples\n    --------\n    Plot dot plot for a set of data points\n\n    .. plot::\n        :context: close-figs\n\n        >>> import arviz as az\n        >>> import numpy as np\n        >>> values = np.random.normal(0, 1, 500)\n        >>> az.plot_dot(values)\n\n    Manually adjust number of quantiles to plot\n\n    .. plot::\n        :context: close-figs\n\n        >>> az.plot_dot(values, nquantiles=100)\n\n    Add a point interval under the dot plot\n\n    .. plot::\n        :context: close-figs\n\n        >>> az.plot_dot(values, point_interval=True)\n\n    Rotate the dot plots by 90 degrees i.e swap x and y axis\n\n    .. plot::\n        :context: close-figs\n\n        >>> az.plot_dot(values, point_interval=True, rotated=True)\n\n    \n\n\n\n\n\n\n","category":"method"},{"location":"api/plots/#ArviZPythonPlots.plot_ecdf-Tuple","page":"Plotting functions","title":"ArviZPythonPlots.plot_ecdf","text":"Plot ECDF or ECDF-Difference Plot with Confidence bands.\n\n    Plots of the empirical CDF estimates of an array. When `values2` argument is provided,\n    the two empirical CDFs are overlaid with the distribution of `values` on top\n    (in a darker shade) and confidence bands in a more transparent shade. Optionally, the difference\n    between the two empirical CDFs can be computed, and the PIT for a single dataset or a comparison\n    between two samples.\n\n    Notes\n    -----\n    This plot computes the confidence bands with the simulated based algorithm presented in [1]_.\n\n    Parameters\n    ----------\n    values : array-like\n        Values to plot from an unknown continuous or discrete distribution.\n    values2 : array-like, optional\n        Values to compare to the original sample.\n    cdf : callable, optional\n        Cumulative distribution function of the distribution to compare the original sample.\n    difference : bool, default False\n        If True then plot ECDF-difference plot otherwise ECDF plot.\n    pit : bool, default False\n        If True plots the ECDF or ECDF-diff of PIT of sample.\n    confidence_bands : bool, default None\n        If True plots the simultaneous or pointwise confidence bands with `1 - fpr`\n        confidence level.\n    pointwise : bool, default False\n        If True plots pointwise confidence bands otherwise simultaneous bands.\n    npoints : int, default 100\n        This denotes the granularity size of our plot i.e the number of evaluation points\n        for the ecdf or ecdf-difference plots.\n    num_trials : int, default 500\n        The number of random ECDFs to generate for constructing simultaneous confidence bands.\n    fpr : float, default 0.05\n        The type I error rate s.t `1 - fpr` denotes the confidence level of bands.\n    figsize : (float,float), optional\n        Figure size. If `None` it will be defined automatically.\n    fill_band : bool, default True\n        If True it fills in between to mark the area inside the confidence interval. Otherwise,\n        plot the border lines.\n    plot_kwargs : dict, optional\n        Additional kwargs passed to :func:`mpl:matplotlib.pyplot.step` or\n        :meth:`bokeh.plotting.figure.step`\n    fill_kwargs : dict, optional\n        Additional kwargs passed to :func:`mpl:matplotlib.pyplot.fill_between` or\n        :meth:`bokeh:bokeh.plotting.Figure.varea`\n    plot_outline_kwargs : dict, optional\n        Additional kwargs passed to :meth:`mpl:matplotlib.axes.Axes.plot` or\n        :meth:`bokeh:bokeh.plotting.Figure.line`\n    ax :axes, optional\n        Matplotlib axes or bokeh figures.\n    show : bool, optional\n        Call backend show function.\n    backend : {\"matplotlib\", \"bokeh\"}, default \"matplotlib\"\n        Select plotting backend.\n    backend_kwargs : dict, optional\n        These are kwargs specific to the backend being used, passed to\n        :func:`matplotlib.pyplot.subplots` or :class:`bokeh.plotting.figure`.\n        For additional documentation check the plotting method of the backend.\n\n    Returns\n    -------\n    axes : matplotlib_axes or bokeh_figure\n\n    References\n    ----------\n    .. [1] Säilynoja, T., Bürkner, P.C. and Vehtari, A., 2021. Graphical Test for\n        Discrete Uniformity and its Applications in Goodness of Fit Evaluation and\n        Multiple Sample Comparison. arXiv preprint arXiv:2103.10522.\n\n    Examples\n    --------\n    Plot ecdf plot for a given sample\n\n    .. plot::\n        :context: close-figs\n\n        >>> import arviz as az\n        >>> from scipy.stats import uniform, binom, norm\n\n        >>> sample = norm(0,1).rvs(1000)\n        >>> az.plot_ecdf(sample)\n\n    Plot ecdf plot with confidence bands for comparing a given sample w.r.t a given distribution\n\n    .. plot::\n        :context: close-figs\n\n        >>> distribution = norm(0,1)\n        >>> az.plot_ecdf(sample, cdf = distribution.cdf, confidence_bands = True)\n\n    Plot ecdf-difference plot with confidence bands for comparing a given sample\n    w.r.t a given distribution\n\n    .. plot::\n        :context: close-figs\n\n        >>> az.plot_ecdf(sample, cdf = distribution.cdf,\n        >>>              confidence_bands = True, difference = True)\n\n    Plot ecdf plot with confidence bands for PIT of sample for comparing a given sample\n    w.r.t a given distribution\n\n    .. plot::\n        :context: close-figs\n\n        >>> az.plot_ecdf(sample, cdf = distribution.cdf,\n        >>>              confidence_bands = True, pit = True)\n\n    Plot ecdf-difference plot with confidence bands for PIT of sample for comparing a given\n    sample w.r.t a given distribution\n\n    .. plot::\n        :context: close-figs\n\n        >>> az.plot_ecdf(sample, cdf = distribution.cdf,\n        >>>              confidence_bands = True, difference = True, pit = True)\n\n    You could also plot the above w.r.t another sample rather than a given distribution.\n    For eg: Plot ecdf-difference plot with confidence bands for PIT of sample for\n    comparing a given sample w.r.t a given sample\n\n    .. plot::\n        :context: close-figs\n\n        >>> sample2 = norm(0,1).rvs(5000)\n        >>> az.plot_ecdf(sample, sample2, confidence_bands = True, difference = True, pit = True)\n\n    \n\n\n\n\n\n\n","category":"method"},{"location":"api/plots/#ArviZPythonPlots.plot_elpd-Tuple","page":"Plotting functions","title":"ArviZPythonPlots.plot_elpd","text":"Plot pointwise elpd differences between two or more models.\n\n    Pointwise model comparison based on their expected log pointwise predictive density (ELPD).\n\n    Notes\n    -----\n    The ELPD is estimated either by Pareto smoothed importance sampling leave-one-out\n    cross-validation (LOO) or using the widely applicable information criterion (WAIC).\n    We recommend LOO in line with the work presented by [1]_.\n\n    Parameters\n    ----------\n    compare_dict : mapping of {str : ELPDData or InferenceData}\n        A dictionary mapping the model name to the object containing inference data or the result\n        of :func:`arviz.loo` or :func:`arviz.waic` functions.\n        Refer to :func:`arviz.convert_to_inference_data` for details on possible dict items.\n    color : str or array_like, default \"C0\"\n        Colors of the scatter plot. If color is a str all dots will have the same color.\n        If it is the size of the observations, each dot will have the specified color.\n        Otherwise, it will be interpreted as a list of the dims to be used for the color code.\n    xlabels : bool, default False\n        Use coords as xticklabels.\n    figsize : (float, float), optional\n        If `None`, size is (8 + numvars, 8 + numvars).\n    textsize : float, optional\n        Text size for labels. If `None` it will be autoscaled based on `figsize`.\n    coords : mapping, optional\n        Coordinates of points to plot. **All** values are used for computation, but only a\n        subset can be plotted for convenience. See :ref:`this section <common_coords>`\n        for usage examples.\n    legend : bool, default False\n        Include a legend to the plot. Only taken into account when color argument is a dim name.\n    threshold : float, optional\n        If some elpd difference is larger than ``threshold * elpd.std()``, show its label. If\n        `None`, no observations will be highlighted.\n    ic : str, optional\n        Information Criterion (\"loo\" for PSIS-LOO, \"waic\" for WAIC) used to compare models.\n        Defaults to ``rcParams[\"stats.information_criterion\"]``.\n        Only taken into account when input is :class:`arviz.InferenceData`.\n    scale : str, optional\n        Scale argument passed to :func:`arviz.loo` or :func:`arviz.waic`, see their docs for\n        details. Only taken into account when values in ``compare_dict`` are\n        :class:`arviz.InferenceData`.\n    var_name : str, optional\n        Argument passed to to :func:`arviz.loo` or :func:`arviz.waic`, see their docs for\n        details. Only taken into account when values in ``compare_dict`` are\n        :class:`arviz.InferenceData`.\n    plot_kwargs : dicts, optional\n        Additional keywords passed to :meth:`matplotlib.axes.Axes.scatter`.\n    ax : axes, optional\n        :class:`matplotlib.axes.Axes` or :class:`bokeh.plotting.Figure`.\n    backend : {\"matplotlib\", \"bokeh\"}, default \"matplotlib\"\n        Select plotting backend.\n    backend_kwargs : dict, optional\n        These are kwargs specific to the backend being used, passed to\n        :func:`matplotlib.pyplot.subplots` or :class:`bokeh.plotting.figure`.\n        For additional documentation check the plotting method of the backend.\n    show : bool, optional\n        Call backend show function.\n\n    Returns\n    -------\n    axes : matplotlib_axes or bokeh_figure\n\n    See Also\n    --------\n    plot_compare : Summary plot for model comparison.\n    loo : Compute Pareto-smoothed importance sampling leave-one-out cross-validation (PSIS-LOO-CV).\n    waic : Compute the widely applicable information criterion.\n\n    References\n    ----------\n    .. [1] Vehtari et al. (2016). Practical Bayesian model evaluation using leave-one-out\n    cross-validation and WAIC https://arxiv.org/abs/1507.04544\n\n    Examples\n    --------\n    Compare pointwise PSIS-LOO for centered and non centered models of the 8-schools problem\n    using matplotlib.\n\n    .. plot::\n        :context: close-figs\n\n        >>> import arviz as az\n        >>> idata1 = az.load_arviz_data(\"centered_eight\")\n        >>> idata2 = az.load_arviz_data(\"non_centered_eight\")\n        >>> az.plot_elpd(\n        >>>     {\"centered model\": idata1, \"non centered model\": idata2},\n        >>>     xlabels=True\n        >>> )\n\n    .. bokeh-plot::\n        :source-position: above\n\n        import arviz as az\n        idata1 = az.load_arviz_data(\"centered_eight\")\n        idata2 = az.load_arviz_data(\"non_centered_eight\")\n        az.plot_elpd(\n            {\"centered model\": idata1, \"non centered model\": idata2},\n            backend=\"bokeh\"\n        )\n\n    \n\n\n\n\n\n\n","category":"method"},{"location":"api/plots/#ArviZPythonPlots.plot_energy-Tuple","page":"Plotting functions","title":"ArviZPythonPlots.plot_energy","text":"Plot energy transition distribution and marginal energy distribution in HMC algorithms.\n\n    This may help to diagnose poor exploration by gradient-based algorithms like HMC or NUTS.\n    The energy function in HMC can identify posteriors with heavy tailed distributions, that\n    in practice are challenging for sampling.\n\n    This plot is in the style of the one used in [1]_.\n\n    Parameters\n    ----------\n    data : obj\n        :class:`xarray.Dataset`, or any object that can be converted (must represent\n        ``sample_stats`` and have an ``energy`` variable).\n    kind : str, optional\n        Type of plot to display (\"kde\", \"hist\").\n    bfmi : bool, default True\n        If True add to the plot the value of the estimated Bayesian fraction of missing\n        information.\n    figsize : (float, float), optional\n        Figure size. If `None` it will be defined automatically.\n    legend : bool, default True\n        Flag for plotting legend.\n    fill_alpha : tuple, default (1, 0.75)\n        Alpha blending value for the shaded area under the curve, between 0\n        (no shade) and 1 (opaque).\n    fill_color : tuple of valid matplotlib color, default ('C0', 'C5')\n        Color for Marginal energy distribution and Energy transition distribution.\n    bw : float or str, optional\n        If numeric, indicates the bandwidth and must be positive.\n        If str, indicates the method to estimate the bandwidth and must be\n        one of \"scott\", \"silverman\", \"isj\" or \"experimental\". Defaults to \"experimental\".\n        Only works if ``kind='kde'``.\n    textsize : float, optional\n        Text size scaling factor for labels, titles and lines. If `None` it will be autoscaled\n        based on `figsize`.\n    fill_kwargs : dicts, optional\n        Additional keywords passed to :func:`arviz.plot_kde` (to control the shade).\n    plot_kwargs : dicts, optional\n        Additional keywords passed to :func:`arviz.plot_kde` or :func:`matplotlib.pyplot.hist`\n        (if ``type='hist'``).\n    ax : axes, optional\n        :class:`matplotlib.axes.Axes` or :class:`bokeh.plotting.Figure`.\n    backend : {\"matplotlib\", \"bokeh\"}, default \"matplotlib\"\n        Select plotting backend.\n    backend_kwargs : dict, optional\n        These are kwargs specific to the backend being used, passed to\n        :func:`matplotlib.pyplot.subplots` or :class:`bokeh.plotting.figure`.\n        For additional documentation check the plotting method of the backend.\n    show : bool, optional\n        Call backend show function.\n\n    Returns\n    -------\n    axes : matplotlib axes or bokeh figures\n\n    See Also\n    --------\n    bfmi : Calculate the estimated Bayesian fraction of missing information (BFMI).\n\n    References\n    ----------\n    .. [1] Betancourt (2016). Diagnosing Suboptimal Cotangent Disintegrations in\n    Hamiltonian Monte Carlo https://arxiv.org/abs/1604.00695\n\n    Examples\n    --------\n    Plot a default energy plot\n\n    .. plot::\n        :context: close-figs\n\n        >>> import arviz as az\n        >>> data = az.load_arviz_data('centered_eight')\n        >>> az.plot_energy(data)\n\n    Represent energy plot via histograms\n\n    .. plot::\n        :context: close-figs\n\n        >>> az.plot_energy(data, kind='hist')\n\n    \n\n\n\n\n\n\n","category":"method"},{"location":"api/plots/#ArviZPythonPlots.plot_ess-Tuple","page":"Plotting functions","title":"ArviZPythonPlots.plot_ess","text":"Generate quantile, local, or evolution ESS plots.\n\n    The local and the quantile ESS plots are recommended for checking\n    that there are enough samples for all the explored regions of the\n    parameter space. Checking local and quantile ESS is particularly\n    relevant when working with HDI intervals as opposed to ESS bulk,\n    which is suitable for point estimates.\n\n    Parameters\n    ----------\n    idata : InferenceData\n        Any object that can be converted to an :class:`arviz.InferenceData` object\n        Refer to documentation of :func:`arviz.convert_to_dataset` for details.\n    var_names : list of str, optional\n        Variables to be plotted. Prefix the variables by ``~`` when you want to exclude\n        them from the plot. See :ref:`this section <common_var_names>` for usage examples.\n    filter_vars : {None, \"like\", \"regex\"}, default None\n        If `None` (default), interpret `var_names` as the real variables names. If \"like\",\n        interpret `var_names` as substrings of the real variables names. If \"regex\",\n        interpret `var_names` as regular expressions on the real variables names. See\n        :ref:`this section <common_filter_vars>` for usage examples.\n    kind : {\"local\", \"quantile\", \"evolution\"}, default \"local\"\n        Specify the kind of plot:\n\n        * The ``kind=\"local\"`` argument generates the ESS' local efficiency for\n          estimating quantiles of a desired posterior.\n        * The ``kind=\"quantile\"`` argument generates the ESS' local efficiency\n          for estimating small-interval probability of a desired posterior.\n        * The ``kind=\"evolution\"`` argument generates the estimated ESS'\n          with incrised number of iterations of a desired posterior.\n\n    relative : bool, default False\n        Show relative ess in plot ``ress = ess / N``.\n    coords : dict, optional\n        Coordinates of `var_names` to be plotted. Passed to :meth:`xarray.Dataset.sel`.\n        See :ref:`this section <common_coords>` for usage examples.\n    grid : tuple, optional\n        Number of rows and columns. By default, the rows and columns are\n        automatically inferred. See :ref:`this section <common_grid>` for usage examples.\n    figsize : (float, float), optional\n        Figure size. If ``None`` it will be defined automatically.\n    textsize : float, optional\n        Text size scaling factor for labels, titles and lines. If ``None`` it will be autoscaled\n        based on `figsize`.\n    rug : bool, default False\n        Add a `rug plot <https://en.wikipedia.org/wiki/Rug_plot>`_ for a specific subset of values.\n    rug_kind : str, default \"diverging\"\n        Variable in sample stats to use as rug mask. Must be a boolean variable.\n    n_points : int, default 20\n        Number of points for which to plot their quantile/local ess or number of subsets\n        in the evolution plot.\n    extra_methods : bool, default False\n        Plot mean and sd ESS as horizontal lines. Not taken into account if ``kind = 'evolution'``.\n    min_ess : int, default 400\n        Minimum number of ESS desired. If ``relative=True`` the line is plotted at\n        ``min_ess / n_samples`` for local and quantile kinds and as a curve following\n        the ``min_ess / n`` dependency in evolution kind.\n    labeller : Labeller, optional\n        Class providing the method ``make_label_vert`` to generate the labels in the plot titles.\n        Read the :ref:`label_guide` for more details and usage examples.\n    ax : 2D array-like of matplotlib_axes or bokeh_figure, optional\n        A 2D array of locations into which to plot the densities. If not supplied, ArviZ will create\n        its own array of plot areas (and return it).\n    extra_kwargs : dict, optional\n        If evolution plot, `extra_kwargs` is used to plot ess tail and differentiate it\n        from ess bulk. Otherwise, passed to extra methods lines.\n    text_kwargs : dict, optional\n        Only taken into account when ``extra_methods=True``. kwargs passed to ax.annotate\n        for extra methods lines labels. It accepts the additional\n        key ``x`` to set ``xy=(text_kwargs[\"x\"], mcse)``\n    hline_kwargs : dict, optional\n        kwargs passed to :func:`~matplotlib.axes.Axes.axhline` or to :class:`~bokeh.models.Span`\n        depending on the backend for the horizontal minimum ESS line.\n        For relative ess evolution plots the kwargs are passed to\n        :func:`~matplotlib.axes.Axes.plot` or to :class:`~bokeh.plotting.figure.line`\n    rug_kwargs : dict\n        kwargs passed to rug plot.\n    backend : {\"matplotlib\", \"bokeh\"}, default \"matplotlib\"\n        Select plotting backend.\n    backend_kwargs : dict, optional\n        These are kwargs specific to the backend being used, passed to\n        :func:`matplotlib.pyplot.subplots` or :class:`bokeh.plotting.figure`.\n        For additional documentation check the plotting method of the backend.\n    show : bool, optional\n        Call backend show function.\n    **kwargs\n        Passed as-is to :meth:`mpl:matplotlib.axes.Axes.hist` or\n        :meth:`mpl:matplotlib.axes.Axes.plot` function depending on the\n        value of `kind`.\n\n    Returns\n    -------\n    axes : matplotlib_axes or bokeh_figure\n\n    See Also\n    --------\n    ess : Calculate estimate of the effective sample size.\n\n    References\n    ----------\n    .. [1] Vehtari et al. (2019). Rank-normalization, folding, and\n        localization: An improved Rhat for assessing convergence of\n        MCMC https://arxiv.org/abs/1903.08008\n\n    Examples\n    --------\n    Plot local ESS.\n\n    .. plot::\n        :context: close-figs\n\n        >>> import arviz as az\n        >>> idata = az.load_arviz_data(\"centered_eight\")\n        >>> coords = {\"school\": [\"Choate\", \"Lawrenceville\"]}\n        >>> az.plot_ess(\n        ...     idata, kind=\"local\", var_names=[\"mu\", \"theta\"], coords=coords\n        ... )\n\n    Plot ESS evolution as the number of samples increase. When the model is converging properly,\n    both lines in this plot should be roughly linear.\n\n    .. plot::\n        :context: close-figs\n\n        >>> az.plot_ess(\n        ...     idata, kind=\"evolution\", var_names=[\"mu\", \"theta\"], coords=coords\n        ... )\n\n    Customize local ESS plot to look like reference paper.\n\n    .. plot::\n        :context: close-figs\n\n        >>> az.plot_ess(\n        ...     idata, kind=\"local\", var_names=[\"mu\"], drawstyle=\"steps-mid\", color=\"k\",\n        ...     linestyle=\"-\", marker=None, rug=True, rug_kwargs={\"color\": \"r\"}\n        ... )\n\n    Customize ESS evolution plot to look like reference paper.\n\n    .. plot::\n        :context: close-figs\n\n        >>> extra_kwargs = {\"color\": \"lightsteelblue\"}\n        >>> az.plot_ess(\n        ...     idata, kind=\"evolution\", var_names=[\"mu\"],\n        ...     color=\"royalblue\", extra_kwargs=extra_kwargs\n        ... )\n\n    \n\n\n\n\n\n\n","category":"method"},{"location":"api/plots/#ArviZPythonPlots.plot_forest-Tuple","page":"Plotting functions","title":"ArviZPythonPlots.plot_forest","text":"Forest plot to compare HDI intervals from a number of distributions.\n\n    Generate forest or ridge plots to compare distributions from a model or list of models.\n    Additionally, the function can display effective sample sizes (ess) and Rhats to visualize\n    convergence diagnostics alongside the distributions.\n\n    Parameters\n    ----------\n    data : InferenceData\n        Any object that can be converted to an :class:`arviz.InferenceData` object\n        Refer to documentation of :func:`arviz.convert_to_dataset` for details.\n    kind : {\"foresplot\", \"ridgeplot\"}, default \"forestplot\"\n        Specify the kind of plot:\n\n        * The ``kind=\"forestplot\"`` generates credible intervals, where the central points are the\n          estimated posterior means, the thick lines are the central quartiles, and the thin lines\n          represent the :math:`100\\times`(`hdi_prob`)% highest density intervals.\n        * The ``kind=\"ridgeplot\"`` option generates density plots (kernel density estimate or\n          histograms) in the same graph. Ridge plots can be configured to have different overlap,\n          truncation bounds and quantile markers.\n\n    model_names : list of str, optional\n        List with names for the models in the list of data. Useful when plotting more that one\n        dataset.\n    var_names : list of str, optional\n        Variables to be plotted. Prefix the variables by ``~`` when you want to exclude\n        them from the plot. See :ref:`this section <common_var_names>` for usage examples.\n    combine_dims : set_like of str, optional\n        List of dimensions to reduce. Defaults to reducing only the \"chain\" and \"draw\" dimensions.\n        See :ref:`this section <common_combine_dims>` for usage examples.\n    filter_vars : {None, \"like\", \"regex\"}, default None\n        If `None` (default), interpret `var_names` as the real variables names. If \"like\",\n        interpret `var_names` as substrings of the real variables names. If \"regex\",\n        interpret `var_names` as regular expressions on the real variables names. See\n        :ref:`this section <common_filter_vars>` for usage examples.\n    transform : callable, optional\n        Function to transform data (defaults to None i.e.the identity function).\n    coords : dict, optional\n        Coordinates of ``var_names`` to be plotted. Passed to :meth:`xarray.Dataset.sel`.\n        See :ref:`this section <common_coords>` for usage examples.\n    combined : bool, default False\n        Flag for combining multiple chains into a single chain. If False, chains will\n        be plotted separately. See :ref:`this section <common_combine>` for usage examples.\n    hdi_prob : float, default 0.94\n        Plots highest posterior density interval for chosen percentage of density.\n        See :ref:`this section <common_ hdi_prob>` for usage examples.\n    rope : tuple or dictionary of tuples\n        Lower and upper values of the Region of Practical Equivalence. If a list with one interval\n        only is provided, the ROPE will be displayed across the y-axis. If more than one\n        interval is provided the length of the list should match the number of variables.\n    quartiles : bool, default True\n        Flag for plotting the interquartile range, in addition to the ``hdi_prob`` intervals.\n    r_hat : bool, default False\n        Flag for plotting Split R-hat statistics. Requires 2 or more chains.\n    ess : bool, default False\n        Flag for plotting the effective sample size.\n    colors : list or string, optional\n        list with valid matplotlib colors, one color per model. Alternative a string can be passed.\n        If the string is `cycle`, it will automatically chose a color per model from the matplotlibs\n        cycle. If a single color is passed, eg 'k', 'C2', 'red' this color will be used for all\n        models. Defaults to 'cycle'.\n    textsize : float, optional\n        Text size scaling factor for labels, titles and lines. If `None` it will be autoscaled based\n        on ``figsize``.\n    linewidth : int, optional\n        Line width throughout. If `None` it will be autoscaled based on ``figsize``.\n    markersize : int, optional\n        Markersize throughout. If `None` it will be autoscaled based on ``figsize``.\n    legend : bool, optional\n        Show a legend with the color encoded model information.\n        Defaults to True, if there are multiple models.\n    labeller : Labeller, optional\n        Class providing the method ``make_label_vert`` to generate the labels in the plot titles.\n        Read the :ref:`label_guide` for more details and usage examples.\n    ridgeplot_alpha: float, optional\n        Transparency for ridgeplot fill.  If ``ridgeplot_alpha=0``, border is colored by model,\n        otherwise a `black` outline is used.\n    ridgeplot_overlap : float, default 2\n        Overlap height for ridgeplots.\n    ridgeplot_kind : string, optional\n        By default (\"auto\") continuous variables are plotted using KDEs and discrete ones using\n        histograms. To override this use \"hist\" to plot histograms and \"density\" for KDEs.\n    ridgeplot_truncate : bool, default True\n        Whether to truncate densities according to the value of ``hdi_prob``.\n    ridgeplot_quantiles : list, optional\n        Quantiles in ascending order used to segment the KDE. Use [.25, .5, .75] for quartiles.\n    figsize : (float, float), optional\n        Figure size. If `None`, it will be defined automatically.\n    ax : axes, optional\n        :class:`matplotlib.axes.Axes` or :class:`bokeh.plotting.Figure`.\n    backend : {\"matplotlib\", \"bokeh\"}, default \"matplotlib\"\n        Select plotting backend.\n    backend_config : dict, optional\n        Currently specifies the bounds to use for bokeh axes. Defaults to value set in ``rcParams``.\n    backend_kwargs : dict, optional\n        These are kwargs specific to the backend being used, passed to\n        :func:`matplotlib.pyplot.subplots` or :class:`bokeh.plotting.figure`.\n        For additional documentation check the plotting method of the backend.\n    show : bool, optional\n        Call backend show function.\n\n    Returns\n    -------\n    1D ndarray of matplotlib_axes or bokeh_figures\n\n    See Also\n    --------\n    plot_posterior : Plot Posterior densities in the style of John K. Kruschke's book.\n    plot_density : Generate KDE plots for continuous variables and histograms for discrete ones.\n    summary : Create a data frame with summary statistics.\n\n    Examples\n    --------\n    Forestplot\n\n    .. plot::\n        :context: close-figs\n\n        >>> import arviz as az\n        >>> non_centered_data = az.load_arviz_data('non_centered_eight')\n        >>> axes = az.plot_forest(non_centered_data,\n        >>>                            kind='forestplot',\n        >>>                            var_names=[\"^the\"],\n        >>>                            filter_vars=\"regex\",\n        >>>                            combined=True,\n        >>>                            figsize=(9, 7))\n        >>> axes[0].set_title('Estimated theta for 8 schools model')\n\n    Forestplot with multiple datasets\n\n    .. plot::\n        :context: close-figs\n\n        >>> centered_data = az.load_arviz_data('centered_eight')\n        >>> axes = az.plot_forest([non_centered_data, centered_data],\n        >>>                            model_names = [\"non centered eight\", \"centered eight\"],\n        >>>                            kind='forestplot',\n        >>>                            var_names=[\"^the\"],\n        >>>                            filter_vars=\"regex\",\n        >>>                            combined=True,\n        >>>                            figsize=(9, 7))\n        >>> axes[0].set_title('Estimated theta for 8 schools models')\n\n    Forestplot with ropes\n\n    .. plot::\n        :context: close-figs\n\n        >>> rope = {'theta': [{'school': 'Choate', 'rope': (2, 4)}], 'mu': [{'rope': (-2, 2)}]}\n        >>> axes = az.plot_forest(non_centered_data,\n        >>>                            rope=rope,\n        >>>                            var_names='~tau',\n        >>>                            combined=True,\n        >>>                            figsize=(9, 7))\n        >>> axes[0].set_title('Estimated theta for 8 schools model')\n\n\n    Ridgeplot\n\n    .. plot::\n        :context: close-figs\n\n        >>> axes = az.plot_forest(non_centered_data,\n        >>>                            kind='ridgeplot',\n        >>>                            var_names=['theta'],\n        >>>                            combined=True,\n        >>>                            ridgeplot_overlap=3,\n        >>>                            colors='white',\n        >>>                            figsize=(9, 7))\n        >>> axes[0].set_title('Estimated theta for 8 schools model')\n\n    Ridgeplot non-truncated and with quantiles\n\n    .. plot::\n        :context: close-figs\n\n        >>> axes = az.plot_forest(non_centered_data,\n        >>>                            kind='ridgeplot',\n        >>>                            var_names=['theta'],\n        >>>                            combined=True,\n        >>>                            ridgeplot_truncate=False,\n        >>>                            ridgeplot_quantiles=[.25, .5, .75],\n        >>>                            ridgeplot_overlap=0.7,\n        >>>                            colors='white',\n        >>>                            figsize=(9, 7))\n        >>> axes[0].set_title('Estimated theta for 8 schools model')\n    \n\n\n\n\n\n\n","category":"method"},{"location":"api/plots/#ArviZPythonPlots.plot_hdi-Tuple","page":"Plotting functions","title":"ArviZPythonPlots.plot_hdi","text":"\n    Plot HDI intervals for regression data.\n\n    Parameters\n    ----------\n    x : array-like\n        Values to plot.\n    y : array-like, optional\n        Values from which to compute the HDI. Assumed shape ``(chain, draw, \\*shape)``.\n        Only optional if ``hdi_data`` is present.\n    hdi_data : array_like, optional\n        Precomputed HDI values to use. Assumed shape is ``(*x.shape, 2)``.\n    hdi_prob : float, optional\n        Probability for the highest density interval. Defaults to ``stats.hdi_prob`` rcParam.\n    color : str, optional\n        Color used for the limits of the HDI and fill. Should be a valid matplotlib color.\n    circular : bool, optional\n        Whether to compute the HDI taking into account ``x`` is a circular variable\n        (in the range [-np.pi, np.pi]) or not. Defaults to False (i.e non-circular variables).\n    smooth : boolean, optional\n        If True the result will be smoothed by first computing a linear interpolation of the data\n        over a regular grid and then applying the Savitzky-Golay filter to the interpolated data.\n        Defaults to True.\n    smooth_kwargs : dict, optional\n        Additional keywords modifying the Savitzky-Golay filter. See\n        :func:`scipy:scipy.signal.savgol_filter` for details.\n    figsize : tuple\n        Figure size. If None it will be defined automatically.\n    fill_kwargs : dict, optional\n        Keywords passed to :meth:`mpl:matplotlib.axes.Axes.fill_between`\n        (use ``fill_kwargs={'alpha': 0}`` to disable fill) or to\n        :meth:`bokeh.plotting.Figure.patch`.\n    plot_kwargs : dict, optional\n        HDI limits keyword arguments, passed to :meth:`mpl:matplotlib.axes.Axes.plot` or\n        :meth:`bokeh.plotting.Figure.patch`.\n    hdi_kwargs : dict, optional\n        Keyword arguments passed to :func:`~arviz.hdi`. Ignored if ``hdi_data`` is present.\n    ax : axes, optional\n        Matplotlib axes or bokeh figures.\n    backend : {\"matplotlib\",\"bokeh\"}, optional\n        Select plotting backend.\n    backend_kwargs : bool, optional\n        These are kwargs specific to the backend being used, passed to\n        :meth:`mpl:matplotlib.axes.Axes.plot` or\n        :meth:`bokeh.plotting.Figure.patch`.\n    show : bool, optional\n        Call backend show function.\n\n    Returns\n    -------\n    axes : matplotlib axes or bokeh figures\n\n    See Also\n    --------\n    hdi : Calculate highest density interval (HDI) of array for given probability.\n\n    Examples\n    --------\n    Plot HDI interval of simulated regression data using `y` argument:\n\n    .. plot::\n        :context: close-figs\n\n        >>> import numpy as np\n        >>> import arviz as az\n        >>> x_data = np.random.normal(0, 1, 100)\n        >>> y_data = np.random.normal(2 + x_data * 0.5, 0.5, size=(2, 50, 100))\n        >>> az.plot_hdi(x_data, y_data)\n\n    ``plot_hdi`` can also be given precalculated values with the argument ``hdi_data``. This example\n    shows how to use :func:`~arviz.hdi` to precalculate the values and pass these values to\n    ``plot_hdi``. Similarly to an example in ``hdi`` we are using the ``input_core_dims``\n    argument of :func:`~arviz.wrap_xarray_ufunc` to manually define the dimensions over which\n    to calculate the HDI.\n\n    .. plot::\n        :context: close-figs\n\n        >>> hdi_data = az.hdi(y_data, input_core_dims=[[\"draw\"]])\n        >>> ax = az.plot_hdi(x_data, hdi_data=hdi_data[0], color=\"r\", fill_kwargs={\"alpha\": .2})\n        >>> az.plot_hdi(x_data, hdi_data=hdi_data[1], color=\"k\", ax=ax, fill_kwargs={\"alpha\": .2})\n\n    ``plot_hdi`` can also be used with Inference Data objects. Here we use the posterior predictive\n    to plot the HDI interval.\n\n    .. plot::\n        :context: close-figs\n\n        >>> X = np.random.normal(0,1,100)\n        >>> Y = np.random.normal(2 + X * 0.5, 0.5, size=(2,10,100))\n        >>> idata = az.from_dict(posterior={\"y\": Y}, constant_data={\"x\":X})\n        >>> x_data = idata.constant_data.x\n        >>> y_data = idata.posterior.y\n        >>> az.plot_hdi(x_data, y_data)\n\n    \n\n\n\n\n\n\n","category":"method"},{"location":"api/plots/#ArviZPythonPlots.plot_kde-Tuple","page":"Plotting functions","title":"ArviZPythonPlots.plot_kde","text":"1D or 2D KDE plot taking into account boundary conditions.\n\n    Parameters\n    ----------\n    values : array-like\n        Values to plot\n    values2 : array-like, optional\n        Values to plot. If present, a 2D KDE will be estimated\n    cumulative : bool\n        If true plot the estimated cumulative distribution function. Defaults to False.\n        Ignored for 2D KDE\n    rug : bool\n        If True adds a rugplot. Defaults to False. Ignored for 2D KDE\n    label : string\n        Text to include as part of the legend\n    bw : float or str, optional\n        If numeric, indicates the bandwidth and must be positive.\n        If str, indicates the method to estimate the bandwidth and must be\n        one of \"scott\", \"silverman\", \"isj\" or \"experimental\" when ``is_circular`` is False\n        and \"taylor\" (for now) when ``is_circular`` is True.\n        Defaults to \"default\" which means \"experimental\" when variable is not circular\n        and \"taylor\" when it is.\n    adaptive : bool, optional.\n        If True, an adaptative bandwidth is used. Only valid for 1D KDE.\n        Defaults to False.\n    quantiles : list\n        Quantiles in ascending order used to segment the KDE.\n        Use [.25, .5, .75] for quartiles. Defaults to None.\n    rotated : bool\n        Whether to rotate the 1D KDE plot 90 degrees.\n    contour : bool\n        If True plot the 2D KDE using contours, otherwise plot a smooth 2D KDE.\n        Defaults to True.\n    hdi_probs : list\n        Plots highest density credibility regions for the provided probabilities for a 2D KDE.\n        Defaults to matplotlib chosen levels with no fixed probability associated.\n    fill_last : bool\n        If True fill the last contour of the 2D KDE plot. Defaults to False.\n    figsize : (float, float), optional\n        Figure size. If None it will be defined automatically.\n    textsize : float\n        Text size scaling factor for labels, titles and lines. If None it will be autoscaled based\n        on ``figsize``. Not implemented for bokeh backend.\n    plot_kwargs : dict\n        Keywords passed to the pdf line of a 1D KDE. See :meth:`mpl:matplotlib.axes.Axes.plot`\n        or :meth:`bokeh:bokeh.plotting.Figure.line` for a description of accepted values.\n    fill_kwargs : dict\n        Keywords passed to the fill under the line (use ``fill_kwargs={'alpha': 0}``\n        to disable fill). Ignored for 2D KDE. Passed to\n        :meth:`bokeh.plotting.Figure.patch`.\n    rug_kwargs : dict\n        Keywords passed to the rug plot. Ignored if ``rug=False`` or for 2D KDE\n        Use ``space`` keyword (float) to control the position of the rugplot. The larger this number\n        the lower the rugplot. Passed to :class:`bokeh:bokeh.models.glyphs.Scatter`.\n    contour_kwargs : dict\n        Keywords passed to :meth:`mpl:matplotlib.axes.Axes.contour`\n        to draw contour lines or :meth:`bokeh.plotting.Figure.patch`.\n        Ignored for 1D KDE.\n    contourf_kwargs : dict\n        Keywords passed to :meth:`mpl:matplotlib.axes.Axes.contourf`\n        to draw filled contours. Ignored for 1D KDE.\n    pcolormesh_kwargs : dict\n        Keywords passed to :meth:`mpl:matplotlib.axes.Axes.pcolormesh` or\n        :meth:`bokeh.plotting.Figure.image`.\n        Ignored for 1D KDE.\n    is_circular : {False, True, \"radians\", \"degrees\"}. Default False.\n        Select input type {\"radians\", \"degrees\"} for circular histogram or KDE plot. If True,\n        default input type is \"radians\". When this argument is present, it interprets ``values``\n        is a circular variable measured in radians and a circular KDE is used. Inputs in\n        \"degrees\" will undergo an internal conversion to radians.\n    ax : axes, optional\n        Matplotlib axes or bokeh figures.\n    legend : bool\n        Add legend to the figure. By default True.\n    backend: str, optional\n        Select plotting backend {\"matplotlib\",\"bokeh\"}. Default \"matplotlib\".\n    backend_kwargs: bool, optional\n        These are kwargs specific to the backend being used, passed to\n        :func:`matplotlib.pyplot.subplots` or\n        :func:`bokeh.plotting.figure`. For additional documentation\n        check the plotting method of the backend.\n    show : bool, optional\n        Call backend show function.\n    return_glyph : bool, optional\n        Internal argument to return glyphs for bokeh\n\n    Returns\n    -------\n    axes : matplotlib.Axes or bokeh.plotting.Figure\n        Object containing the kde plot\n    glyphs : list, optional\n        Bokeh glyphs present in plot.  Only provided if ``return_glyph`` is True.\n\n    See Also\n    --------\n    kde : One dimensional density estimation.\n    plot_dist : Plot distribution as histogram or kernel density estimates.\n\n    Examples\n    --------\n    Plot default KDE\n\n    .. plot::\n        :context: close-figs\n\n        >>> import arviz as az\n        >>> non_centered = az.load_arviz_data('non_centered_eight')\n        >>> mu_posterior = np.concatenate(non_centered.posterior[\"mu\"].values)\n        >>> tau_posterior = np.concatenate(non_centered.posterior[\"tau\"].values)\n        >>> az.plot_kde(mu_posterior)\n\n\n    Plot KDE with rugplot\n\n    .. plot::\n        :context: close-figs\n\n        >>> az.plot_kde(mu_posterior, rug=True)\n\n    Plot KDE with adaptive bandwidth\n\n    .. plot::\n        :context: close-figs\n\n        >>> az.plot_kde(mu_posterior, adaptive=True)\n\n    Plot KDE with a different bandwidth estimator\n\n    .. plot::\n        :context: close-figs\n\n        >>> az.plot_kde(mu_posterior, bw=\"scott\")\n\n    Plot KDE with a bandwidth specified manually\n\n    .. plot::\n        :context: close-figs\n\n        >>> az.plot_kde(mu_posterior, bw=0.4)\n\n    Plot KDE for a circular variable\n\n    .. plot::\n        :context: close-figs\n\n        >>> rvs = np.random.vonmises(mu=np.pi, kappa=2, size=500)\n        >>> az.plot_kde(rvs, is_circular=True)\n\n\n    Plot a cumulative distribution\n\n    .. plot::\n        :context: close-figs\n\n        >>> az.plot_kde(mu_posterior, cumulative=True)\n\n\n\n    Rotate plot 90 degrees\n\n    .. plot::\n        :context: close-figs\n\n        >>> az.plot_kde(mu_posterior, rotated=True)\n\n\n    Plot 2d contour KDE\n\n    .. plot::\n        :context: close-figs\n\n        >>> az.plot_kde(mu_posterior, values2=tau_posterior)\n\n\n    Plot 2d contour KDE, without filling and contour lines using viridis cmap\n\n    .. plot::\n        :context: close-figs\n\n        >>> az.plot_kde(mu_posterior, values2=tau_posterior,\n        ...             contour_kwargs={\"colors\":None, \"cmap\":plt.cm.viridis},\n        ...             contourf_kwargs={\"alpha\":0});\n\n    Plot 2d contour KDE, set the number of levels to 3.\n\n    .. plot::\n        :context: close-figs\n\n        >>> az.plot_kde(\n        ...     mu_posterior, values2=tau_posterior,\n        ...     contour_kwargs={\"levels\":3}, contourf_kwargs={\"levels\":3}\n        ... );\n\n    Plot 2d contour KDE with 30%, 60% and 90% HDI contours.\n\n    .. plot::\n        :context: close-figs\n\n        >>> az.plot_kde(mu_posterior, values2=tau_posterior, hdi_probs=[0.3, 0.6, 0.9])\n\n    Plot 2d smooth KDE\n\n    .. plot::\n        :context: close-figs\n\n        >>> az.plot_kde(mu_posterior, values2=tau_posterior, contour=False)\n\n    \n\n\n\n\n\n\n","category":"method"},{"location":"api/plots/#ArviZPythonPlots.plot_khat-Tuple","page":"Plotting functions","title":"ArviZPythonPlots.plot_khat","text":"\n    Plot Pareto tail indices for diagnosing convergence.\n\n    Parameters\n    ----------\n    khats : ELPDData containing Pareto shapes information or array of\n        Pareto tail indices.\n    color : str or array_like, optional\n        Colors of the scatter plot, if color is a str all dots will\n        have the same color, if it is the size of the observations,\n        each dot will have the specified color, otherwise, it will be\n        interpreted as a list of the dims to be used for the color\n        code. If Matplotlib c argument is passed, it will override\n        the color argument\n    xlabels : bool, optional\n        Use coords as xticklabels\n    show_hlines : bool, optional\n        Show the horizontal lines, by default at the values [0, 0.5, 0.7, 1].\n    show_bins : bool, optional\n        Show the percentage of khats falling in each bin, as delimited by hlines.\n    bin_format : str, optional\n        The string is used as formatting guide calling ``bin_format.format(count, pct)``.\n    threshold : float, optional\n        Show the labels of k values larger than threshold. Defaults to `None`,\n        no observations will be highlighted.\n    hover_label : bool, optional\n        Show the datapoint label when hovering over it with the mouse. Requires an interactive\n        backend.\n    hover_format : str, optional\n        String used to format the hover label via ``hover_format.format(idx, coord_label)``\n    figsize : (float, float), optional\n        Figure size. If None it will be defined automatically.\n    textsize : float, optional\n        Text size scaling factor for labels, titles and lines. If None it will be autoscaled based\n        on figsize.\n    coords : mapping, optional\n        Coordinates of points to plot. **All** values are used for computation, but only a\n        a subset can be plotted for convenience.\n    legend : bool, optional\n        Include a legend to the plot. Only taken into account when color argument is a dim name.\n    markersize : int, optional\n        markersize for scatter plot. Defaults to `None` in which case it will\n        be chosen based on autoscaling for figsize.\n    ax : axes, optional\n        Matplotlib axes or bokeh figures.\n    hlines_kwargs : dictionary, optional\n        Additional keywords passed to\n        :meth:`matplotlib.axes.Axes.hlines`.\n    backend : str, optional\n        Select plotting backend {\"matplotlib\",\"bokeh\"}. Default \"matplotlib\".\n    backend_kwargs : bool, optional\n        These are kwargs specific to the backend being used, passed to\n        :func:`matplotlib.pyplot.subplots` or\n        :func:`bokeh.plotting.figure`.\n    show : bool, optional\n        Call backend show function.\n    kwargs :\n        Additional keywords passed to\n        :meth:`matplotlib.axes.Axes.scatter`.\n\n    Returns\n    -------\n    axes : matplotlib_axes or bokeh_figures\n\n    See Also\n    --------\n    psislw : Pareto smoothed importance sampling (PSIS).\n\n    Examples\n    --------\n    Plot estimated pareto shape parameters showing how many fall in each category.\n\n    .. plot::\n        :context: close-figs\n\n        >>> import arviz as az\n        >>> radon = az.load_arviz_data(\"radon\")\n        >>> loo_radon = az.loo(radon, pointwise=True)\n        >>> az.plot_khat(loo_radon, show_bins=True)\n\n    Show xlabels\n\n    .. plot::\n        :context: close-figs\n\n        >>> centered_eight = az.load_arviz_data(\"centered_eight\")\n        >>> khats = az.loo(centered_eight, pointwise=True).pareto_k\n        >>> az.plot_khat(khats, xlabels=True, threshold=1)\n\n    Use custom color scheme\n\n    .. plot::\n        :context: close-figs\n\n        >>> counties = radon.posterior.County[radon.constant_data.county_idx].values\n        >>> colors = [\n        ...     \"blue\" if county[-1] in (\"A\", \"N\") else \"green\" for county in counties\n        ... ]\n        >>> az.plot_khat(loo_radon, color=colors)\n\n    Notes\n    -----\n    The Generalized Pareto distribution (GPD) may be used to diagnose\n    convergence rates for importance sampling.  GPD has parameters\n    offset, scale, and shape. The shape parameter is usually denoted\n    with ``k``. ``k`` also tells how many finite moments the\n    distribution has. The pre-asymptotic convergence rate of\n    importance sampling can be estimated based on the fractional\n    number of finite moments of the importance ratio distribution. GPD\n    is fitted to the largest importance ratios and the estimated shape\n    parameter ``k``, i.e., ``\\hat{k}`` can then be used as a diagnostic\n    (most importantly if ``\\hat{k} > 0.7``, then the convergence rate\n    is impractically low). See [1]_.\n\n    References\n    ----------\n    .. [1] Vehtari, A., Simpson, D., Gelman, A., Yao, Y., Gabry, J.,\n        2019. Pareto Smoothed Importance Sampling. arXiv:1507.02646 [stat].\n\n    \n\n\n\n\n\n\n","category":"method"},{"location":"api/plots/#ArviZPythonPlots.plot_lm-Tuple","page":"Plotting functions","title":"ArviZPythonPlots.plot_lm","text":"Posterior predictive and mean plots for regression-like data.\n\n    Parameters\n    ----------\n    y : str or DataArray or ndarray\n        If str, variable name from ``observed_data``.\n    idata : InferenceData, Optional\n        Optional only if ``y`` is not str.\n    x : str, tuple of strings, DataArray or array-like, optional\n        If str or tuple, variable name from ``constant_data``.\n        If ndarray, could be 1D, or 2D for multiple plots.\n        If None, coords name of ``y`` (``y`` should be DataArray).\n    y_model : str or Sequence, Optional\n        If str, variable name from ``posterior``.\n        Its dimensions should be same as ``y`` plus added chains and draws.\n    y_hat : str, Optional\n        If str, variable name from ``posterior_predictive``.\n        Its dimensions should be same as ``y`` plus added chains and draws.\n    num_samples : int, Optional, Default 50\n        Significant if ``kind_pp`` is \"samples\" or ``kind_model`` is \"lines\".\n        Number of samples to be drawn from posterior predictive or\n    kind_pp : {\"samples\", \"hdi\"}, Default \"samples\"\n        Options to visualize uncertainty in data.\n    kind_model : {\"lines\", \"hdi\"}, Default \"lines\"\n        Options to visualize uncertainty in mean of the data.\n    plot_dim : str, Optional\n        Necessary if ``y`` is multidimensional.\n    backend : str, Optional\n        Select plotting backend {\"matplotlib\",\"bokeh\"}. Default \"matplotlib\".\n    y_kwargs : dict, optional\n        Passed to :meth:`mpl:matplotlib.axes.Axes.plot` in matplotlib\n        and :meth:`bokeh:bokeh.plotting.Figure.circle` in bokeh\n    y_hat_plot_kwargs : dict, optional\n        Passed to :meth:`mpl:matplotlib.axes.Axes.plot` in matplotlib\n        and :meth:`bokeh:bokeh.plotting.Figure.circle` in bokeh\n    y_hat_fill_kwargs : dict, optional\n        Passed to :func:`arviz.plot_hdi`\n    y_model_plot_kwargs : dict, optional\n        Passed to :meth:`mpl:matplotlib.axes.Axes.plot` in matplotlib\n        and :meth:`bokeh:bokeh.plotting.Figure.line` in bokeh\n    y_model_fill_kwargs : dict, optional\n        Significant if ``kind_model`` is \"hdi\". Passed to :func:`arviz.plot_hdi`\n    y_model_mean_kwargs : dict, optional\n        Passed to :meth:`mpl:matplotlib.axes.Axes.plot` in matplotlib\n        and :meth:`bokeh:bokeh.plotting.Figure.line` in bokeh\n    backend_kwargs : dict, optional\n        These are kwargs specific to the backend being used. Passed to\n        :func:`matplotlib.pyplot.subplots` or\n        :func:`bokeh.plotting.figure`.\n    figsize : (float, float), optional\n        Figure size. If None it will be defined automatically.\n    textsize : float, optional\n        Text size scaling factor for labels, titles and lines. If None it will be\n        autoscaled based on ``figsize``.\n    axes : 2D numpy array-like of matplotlib_axes or bokeh_figures, optional\n        A 2D array of locations into which to plot the densities. If not supplied, Arviz will create\n        its own array of plot areas (and return it).\n    show : bool, optional\n        Call backend show function.\n    legend : bool, optional\n        Add legend to figure. By default True.\n    grid : bool, optional\n        Add grid to figure. By default True.\n\n\n    Returns\n    -------\n    axes: matplotlib axes or bokeh figures\n\n    See Also\n    --------\n    plot_ts : Plot timeseries data\n    plot_ppc : Plot for posterior/prior predictive checks\n\n    Examples\n    --------\n    Plot regression default plot\n\n    .. plot::\n        :context: close-figs\n\n        >>> import arviz as az\n        >>> import numpy as np\n        >>> import xarray as xr\n        >>> idata = az.load_arviz_data('regression1d')\n        >>> x = xr.DataArray(np.linspace(0, 1, 100))\n        >>> idata.posterior[\"y_model\"] = idata.posterior[\"intercept\"] + idata.posterior[\"slope\"]*x\n        >>> az.plot_lm(idata=idata, y=\"y\", x=x)\n\n    Plot regression data and mean uncertainty\n\n    .. plot::\n        :context: close-figs\n\n        >>> az.plot_lm(idata=idata, y=\"y\", x=x, y_model=\"y_model\")\n\n    Plot regression data and mean uncertainty in hdi form\n\n    .. plot::\n        :context: close-figs\n\n        >>> az.plot_lm(\n        ...     idata=idata, y=\"y\", x=x, y_model=\"y_model\", kind_pp=\"hdi\", kind_model=\"hdi\"\n        ... )\n\n    Plot regression data for multi-dimensional y using plot_dim\n\n    .. plot::\n        :context: close-figs\n\n        >>> data = az.from_dict(\n        ...     observed_data = { \"y\": np.random.normal(size=(5, 7)) },\n        ...     posterior_predictive = {\"y\": np.random.randn(4, 1000, 5, 7) / 2},\n        ...     dims={\"y\": [\"dim1\", \"dim2\"]},\n        ...     coords={\"dim1\": range(5), \"dim2\": range(7)}\n        ... )\n        >>> az.plot_lm(idata=data, y=\"y\", plot_dim=\"dim1\")\n    \n\n\n\n\n\n\n","category":"method"},{"location":"api/plots/#ArviZPythonPlots.plot_loo_pit-Tuple","page":"Plotting functions","title":"ArviZPythonPlots.plot_loo_pit","text":"Plot Leave-One-Out (LOO) probability integral transformation (PIT) predictive checks.\n\n    Parameters\n    ----------\n    idata : InferenceData\n        :class:`arviz.InferenceData` object.\n    y : array, DataArray or str\n        Observed data. If str, ``idata`` must be present and contain the observed data group\n    y_hat : array, DataArray or str\n        Posterior predictive samples for ``y``. It must have the same shape as y plus an\n        extra dimension at the end of size n_samples (chains and draws stacked). If str or\n        None, ``idata`` must contain the posterior predictive group. If None, ``y_hat`` is taken\n        equal to y, thus, y must be str too.\n    log_weights : array or DataArray\n        Smoothed log_weights. It must have the same shape as ``y_hat``\n    ecdf : bool, optional\n        Plot the difference between the LOO-PIT Empirical Cumulative Distribution Function\n        (ECDF) and the uniform CDF instead of LOO-PIT kde.\n        In this case, instead of overlaying uniform distributions, the beta ``hdi_prob``\n        around the theoretical uniform CDF is shown. This approximation only holds\n        for large S and ECDF values not very close to 0 nor 1. For more information, see\n        `Vehtari et al. (2019)`, `Appendix G <https://avehtari.github.io/rhat_ess/rhat_ess.html>`_.\n    ecdf_fill : bool, optional\n        Use :meth:`matplotlib.axes.Axes.fill_between` to mark the area\n        inside the credible interval. Otherwise, plot the\n        border lines.\n    n_unif : int, optional\n        Number of datasets to simulate and overlay from the uniform distribution.\n    use_hdi : bool, optional\n        Compute expected hdi values instead of overlaying the sampled uniform distributions.\n    hdi_prob : float, optional\n        Probability for the highest density interval. Works with ``use_hdi=True`` or ``ecdf=True``.\n    figsize : (float, float), optional\n        If None, size is (8 + numvars, 8 + numvars)\n    textsize : int, optional\n        Text size for labels. If None it will be autoscaled based on ``figsize``.\n    labeller : Labeller, optional\n        Class providing the method ``make_pp_label`` to generate the labels in the plot titles.\n        Read the :ref:`label_guide` for more details and usage examples.\n    color : str or array_like, optional\n        Color of the LOO-PIT estimated pdf plot. If ``plot_unif_kwargs`` has no \"color\" key,\n        a slightly lighter color than this argument will be used for the uniform kde lines.\n        This will ensure that LOO-PIT kde and uniform kde have different default colors.\n    legend : bool, optional\n        Show the legend of the figure.\n    ax : axes, optional\n        Matplotlib axes or bokeh figures.\n    plot_kwargs : dict, optional\n        Additional keywords passed to :meth:`matplotlib.axes.Axes.plot`\n        for LOO-PIT line (kde or ECDF)\n    plot_unif_kwargs : dict, optional\n        Additional keywords passed to :meth:`matplotlib.axes.Axes.plot` for\n        overlaid uniform distributions or for beta credible interval\n        lines if ``ecdf=True``\n    hdi_kwargs : dict, optional\n        Additional keywords passed to :meth:`matplotlib.axes.Axes.axhspan`\n    fill_kwargs : dict, optional\n        Additional kwargs passed to :meth:`matplotlib.axes.Axes.fill_between`\n    backend : str, optional\n        Select plotting backend {\"matplotlib\",\"bokeh\"}. Default \"matplotlib\".\n    backend_kwargs : bool, optional\n        These are kwargs specific to the backend being used, passed to\n        :func:`matplotlib.pyplot.subplots` or\n        :func:`bokeh.plotting.figure`. For additional documentation\n        check the plotting method of the backend.\n    show : bool, optional\n        Call backend show function.\n\n    Returns\n    -------\n    axes : matplotlib_axes or bokeh_figures\n\n    See Also\n    --------\n    plot_bpv : Plot Bayesian p-value for observed data and Posterior/Prior predictive.\n    loo_pit : Compute leave one out (PSIS-LOO) probability integral transform (PIT) values.\n\n    References\n    ----------\n    * Gabry et al. (2017) see https://arxiv.org/abs/1709.01449\n    * https://mc-stan.org/bayesplot/reference/PPC-loo.html\n    * Gelman et al. BDA (2014) Section 6.3\n\n    Examples\n    --------\n    Plot LOO-PIT predictive checks overlaying the KDE of the LOO-PIT values to several\n    realizations of uniform variable sampling with the same number of observations.\n\n    .. plot::\n        :context: close-figs\n\n        >>> import arviz as az\n        >>> idata = az.load_arviz_data(\"radon\")\n        >>> az.plot_loo_pit(idata=idata, y=\"y\")\n\n    Fill the area containing the 94% highest density interval of the difference between uniform\n    variables empirical CDF and the real uniform CDF. A LOO-PIT ECDF clearly outside of these\n    theoretical boundaries indicates that the observations and the posterior predictive\n    samples do not follow the same distribution.\n\n    .. plot::\n        :context: close-figs\n\n        >>> az.plot_loo_pit(idata=idata, y=\"y\", ecdf=True)\n\n    \n\n\n\n\n\n\n","category":"method"},{"location":"api/plots/#ArviZPythonPlots.plot_mcse-Tuple","page":"Plotting functions","title":"ArviZPythonPlots.plot_mcse","text":"Plot quantile or local Monte Carlo Standard Error.\n\n    Parameters\n    ----------\n    idata : obj\n        Any object that can be converted to an :class:`arviz.InferenceData` object\n        Refer to documentation of :func:`arviz.convert_to_dataset` for details\n    var_names : list of variable names, optional\n        Variables to be plotted. Prefix the variables by ``~`` when you want to exclude\n        them from the plot.\n    filter_vars : {None, \"like\", \"regex\"}, optional, default=None\n        If `None` (default), interpret var_names as the real variables names. If \"like\",\n        interpret var_names as substrings of the real variables names. If \"regex\",\n        interpret var_names as regular expressions on the real variables names. A la\n        `pandas.filter`.\n    coords : dict, optional\n        Coordinates of var_names to be plotted. Passed to :meth:`xarray.Dataset.sel`\n    errorbar : bool, optional\n        Plot quantile value +/- mcse instead of plotting mcse.\n    grid : tuple\n        Number of rows and columns. Defaults to None, the rows and columns are\n        automatically inferred.\n    figsize : (float, float), optional\n        Figure size. If None it will be defined automatically.\n    textsize : float, optional\n        Text size scaling factor for labels, titles and lines. If None it will be autoscaled based\n        on figsize.\n    extra_methods : bool, optional\n        Plot mean and sd MCSE as horizontal lines. Only taken into account when\n        ``errorbar=False``.\n    rug : bool\n        Plot rug plot of values diverging or that reached the max tree depth.\n    rug_kind : bool\n        Variable in sample stats to use as rug mask. Must be a boolean variable.\n    n_points : int\n        Number of points for which to plot their quantile/local ess or number of subsets\n        in the evolution plot.\n    labeller : Labeller, optional\n        Class providing the method `make_label_vert` to generate the labels in the plot titles.\n        Read the :ref:`label_guide` for more details and usage examples.\n    ax : 2D array-like of matplotlib_axes or bokeh_figures, optional\n        A 2D array of locations into which to plot the densities. If not supplied, Arviz will create\n        its own array of plot areas (and return it).\n    rug_kwargs : dict\n        kwargs passed to rug plot in\n        :meth:`mpl:matplotlib.axes.Axes.plot` or :class:`bokeh:bokeh.models.glyphs.Scatter`.\n    extra_kwargs : dict, optional\n        kwargs passed as extra method lines in\n        :meth:`mpl:matplotlib.axes.Axes.axhline` or :class:`bokeh:bokeh.models.Span`\n    text_kwargs : dict, optional\n        kwargs passed to :meth:`mpl:matplotlib.axes.Axes.annotate` for extra methods lines labels.\n        It accepts the additional key ``x`` to set ``xy=(text_kwargs[\"x\"], mcse)``.\n        text_kwargs are ignored for the bokeh plotting backend.\n    backend : str, optional\n        Select plotting backend {\"matplotlib\",\"bokeh\"}. Default \"matplotlib\".\n    backend_kwargs : bool, optional\n        These are kwargs specific to the backend being passed to\n        :func:`matplotlib.pyplot.subplots` or :func:`bokeh.plotting.figure`.\n    show: bool, optional\n        Call backend show function.\n    **kwargs\n        Passed as-is to :meth:`mpl:matplotlib.axes.Axes.hist` or\n        :meth:`mpl:matplotlib.axes.Axes.plot` in matplotlib depending on the value of `kind`.\n\n    Returns\n    -------\n    axes : matplotlib axes or bokeh figures\n\n    See Also\n    --------\n    :func:`arviz.mcse`: Calculate Markov Chain Standard Error statistic.\n\n    References\n    ----------\n    * Vehtari et al. (2019) see https://arxiv.org/abs/1903.08008\n\n    Examples\n    --------\n    Plot quantile Monte Carlo Standard Error.\n\n    .. plot::\n        :context: close-figs\n\n        >>> import arviz as az\n        >>> idata = az.load_arviz_data(\"centered_eight\")\n        >>> coords = {\"school\": [\"Deerfield\", \"Lawrenceville\"]}\n        >>> az.plot_mcse(\n        ...     idata, var_names=[\"mu\", \"theta\"], coords=coords\n        ... )\n\n    \n\n\n\n\n\n\n","category":"method"},{"location":"api/plots/#ArviZPythonPlots.plot_pair-Tuple","page":"Plotting functions","title":"ArviZPythonPlots.plot_pair","text":"\n    Plot a scatter, kde and/or hexbin matrix with (optional) marginals on the diagonal.\n\n    Parameters\n    ----------\n    data: obj\n        Any object that can be converted to an :class:`arviz.InferenceData` object.\n        Refer to documentation of :func:`arviz.convert_to_dataset` for details\n    group: str, optional\n        Specifies which InferenceData group should be plotted.  Defaults to 'posterior'.\n    var_names: list of variable names, optional\n        Variables to be plotted, if None all variable are plotted. Prefix the\n        variables by ``~`` when you want to exclude them from the plot.\n    filter_vars: {None, \"like\", \"regex\"}, optional, default=None\n        If `None` (default), interpret var_names as the real variables names. If \"like\",\n        interpret var_names as substrings of the real variables names. If \"regex\",\n        interpret var_names as regular expressions on the real variables names. A la\n        ``pandas.filter``.\n    combine_dims : set_like of str, optional\n        List of dimensions to reduce. Defaults to reducing only the \"chain\" and \"draw\" dimensions.\n        See the :ref:`this section <common_combine_dims>` for usage examples.\n    coords: mapping, optional\n        Coordinates of var_names to be plotted. Passed to :meth:`xarray.Dataset.sel`.\n    marginals: bool, optional\n        If True pairplot will include marginal distributions for every variable\n    figsize: figure size tuple\n        If None, size is (8 + numvars, 8 + numvars)\n    textsize: int\n        Text size for labels. If None it will be autoscaled based on ``figsize``.\n    kind : str or List[str]\n        Type of plot to display (scatter, kde and/or hexbin)\n    gridsize: int or (int, int), optional\n        Only works for ``kind=hexbin``. The number of hexagons in the x-direction.\n        The corresponding number of hexagons in the y-direction is chosen\n        such that the hexagons are approximately regular. Alternatively, gridsize\n        can be a tuple with two elements specifying the number of hexagons\n        in the x-direction and the y-direction.\n    divergences: Boolean\n        If True divergences will be plotted in a different color, only if group is either 'prior'\n        or 'posterior'.\n    colorbar: bool\n        If True a colorbar will be included as part of the plot (Defaults to False).\n        Only works when ``kind=hexbin``\n    labeller : labeller instance, optional\n        Class providing the method ``make_label_vert`` to generate the labels in the plot.\n        Read the :ref:`label_guide` for more details and usage examples.\n    ax: axes, optional\n        Matplotlib axes or bokeh figures.\n    divergences_kwargs: dicts, optional\n        Additional keywords passed to :meth:`matplotlib.axes.Axes.scatter` for divergences\n    scatter_kwargs:\n        Additional keywords passed to :meth:`matplotlib.axes.Axes.scatter` when using scatter kind\n    kde_kwargs: dict, optional\n        Additional keywords passed to :func:`arviz.plot_kde` when using kde kind\n    hexbin_kwargs: dict, optional\n        Additional keywords passed to :meth:`matplotlib.axes.Axes.hexbin` when\n        using hexbin kind\n    backend: str, optional\n        Select plotting backend {\"matplotlib\",\"bokeh\"}. Default \"matplotlib\".\n    backend_kwargs: bool, optional\n        These are kwargs specific to the backend being used, passed to\n        :func:`matplotlib.pyplot.subplots` or\n        :func:`bokeh.plotting.figure`.\n    marginal_kwargs: dict, optional\n        Additional keywords passed to :func:`arviz.plot_dist`, modifying the\n        marginal distributions plotted in the diagonal.\n    point_estimate: str, optional\n        Select point estimate from 'mean', 'mode' or 'median'. The point estimate will be\n        plotted using a scatter marker and vertical/horizontal lines.\n    point_estimate_kwargs: dict, optional\n        Additional keywords passed to :meth:`matplotlib.axes.Axes.axvline`,\n        :meth:`matplotlib.axes.Axes.axhline` (matplotlib) or\n        :class:`bokeh:bokeh.models.Span` (bokeh)\n    point_estimate_marker_kwargs: dict, optional\n        Additional keywords passed to :meth:`matplotlib.axes.Axes.scatter`\n        or :meth:`bokeh:bokeh.plotting.Figure.square` in point\n        estimate plot. Not available in bokeh\n    reference_values: dict, optional\n        Reference values for the plotted variables. The Reference values will be plotted\n        using a scatter marker\n    reference_values_kwargs: dict, optional\n        Additional keywords passed to :meth:`matplotlib.axes.Axes.plot` or\n        :meth:`bokeh:bokeh.plotting.Figure.circle` in reference values plot\n    show: bool, optional\n        Call backend show function.\n\n    Returns\n    -------\n    axes: matplotlib axes or bokeh figures\n\n    Examples\n    --------\n    KDE Pair Plot\n\n    .. plot::\n        :context: close-figs\n\n        >>> import arviz as az\n        >>> centered = az.load_arviz_data('centered_eight')\n        >>> coords = {'school': ['Choate', 'Deerfield']}\n        >>> az.plot_pair(centered,\n        >>>             var_names=['theta', 'mu', 'tau'],\n        >>>             kind='kde',\n        >>>             coords=coords,\n        >>>             divergences=True,\n        >>>             textsize=18)\n\n    Hexbin pair plot\n\n    .. plot::\n        :context: close-figs\n\n        >>> az.plot_pair(centered,\n        >>>             var_names=['theta', 'mu'],\n        >>>             coords=coords,\n        >>>             textsize=18,\n        >>>             kind='hexbin')\n\n    Pair plot showing divergences and select variables with regular expressions\n\n    .. plot::\n        :context: close-figs\n\n        >>> az.plot_pair(centered,\n        ...             var_names=['^t', 'mu'],\n        ...             filter_vars=\"regex\",\n        ...             coords=coords,\n        ...             divergences=True,\n        ...             textsize=18)\n    \n\n\n\n\n\n\n","category":"method"},{"location":"api/plots/#ArviZPythonPlots.plot_parallel-Tuple","page":"Plotting functions","title":"ArviZPythonPlots.plot_parallel","text":"\n    Plot parallel coordinates plot showing posterior points with and without divergences.\n\n    Described by https://arxiv.org/abs/1709.01449\n\n    Parameters\n    ----------\n    data: obj\n        Any object that can be converted to an :class:`arviz.InferenceData` object\n        refer to documentation of :func:`arviz.convert_to_dataset` for details\n    var_names: list of variable names\n        Variables to be plotted, if `None` all variables are plotted. Can be used to change the\n        order of the plotted variables. Prefix the variables by ``~`` when you want to exclude\n        them from the plot.\n    filter_vars: {None, \"like\", \"regex\"}, optional, default=None\n        If `None` (default), interpret var_names as the real variables names. If \"like\",\n        interpret var_names as substrings of the real variables names. If \"regex\",\n        interpret var_names as regular expressions on the real variables names. A la\n        ``pandas.filter``.\n    coords: mapping, optional\n        Coordinates of ``var_names`` to be plotted.\n        Passed to :meth:`xarray.Dataset.sel`.\n    figsize: tuple\n        Figure size. If None it will be defined automatically.\n    textsize: float\n        Text size scaling factor for labels, titles and lines. If None it will be autoscaled based\n        on ``figsize``.\n    legend: bool\n        Flag for plotting legend (defaults to True)\n    colornd: valid matplotlib color\n        color for non-divergent points. Defaults to 'k'\n    colord: valid matplotlib color\n        color for divergent points. Defaults to 'C1'\n    shadend: float\n        Alpha blending value for non-divergent points, between 0 (invisible) and 1 (opaque).\n        Defaults to .025\n    labeller : labeller instance, optional\n        Class providing the method ``make_label_vert`` to generate the labels in the plot.\n        Read the :ref:`label_guide` for more details and usage examples.\n    ax: axes, optional\n        Matplotlib axes or bokeh figures.\n    norm_method: str\n        Method for normalizing the data. Methods include normal, minmax and rank.\n        Defaults to none.\n    backend: str, optional\n        Select plotting backend {\"matplotlib\",\"bokeh\"}. Default \"matplotlib\".\n    backend_config: dict, optional\n        Currently specifies the bounds to use for bokeh axes.\n        Defaults to value set in ``rcParams``.\n    backend_kwargs: bool, optional\n        These are kwargs specific to the backend being used, passed to\n        :func:`matplotlib.pyplot.subplots` or\n        :func:`bokeh.plotting.figure`.\n    show: bool, optional\n        Call backend show function.\n\n    Returns\n    -------\n    axes: matplotlib axes or bokeh figures\n\n    See Also\n    --------\n    plot_pair : Plot a scatter, kde and/or hexbin matrix with (optional) marginals on the diagonal.\n    plot_trace : Plot distribution (histogram or kernel density estimates) and sampled values\n                 or rank plot\n\n    Examples\n    --------\n    Plot default parallel plot\n\n    .. plot::\n        :context: close-figs\n\n        >>> import arviz as az\n        >>> data = az.load_arviz_data('centered_eight')\n        >>> az.plot_parallel(data, var_names=[\"mu\", \"tau\"])\n\n\n    Plot parallel plot with normalization\n\n    .. plot::\n        :context: close-figs\n\n        >>> az.plot_parallel(data, var_names=[\"theta\", \"tau\", \"mu\"], norm_method=\"normal\")\n\n    Plot parallel plot with minmax\n\n    .. plot::\n        :context: close-figs\n\n        >>> ax = az.plot_parallel(data, var_names=[\"theta\", \"tau\", \"mu\"], norm_method=\"minmax\")\n        >>> ax.set_xticklabels(ax.get_xticklabels(), rotation=45)\n\n    Plot parallel plot with rank\n\n    .. plot::\n        :context: close-figs\n\n        >>> ax = az.plot_parallel(data, var_names=[\"theta\", \"tau\", \"mu\"], norm_method=\"rank\")\n        >>> ax.set_xticklabels(ax.get_xticklabels(), rotation=45)\n    \n\n\n\n\n\n\n","category":"method"},{"location":"api/plots/#ArviZPythonPlots.plot_posterior-Tuple","page":"Plotting functions","title":"ArviZPythonPlots.plot_posterior","text":"Plot Posterior densities in the style of John K. Kruschke's book.\n\n    Parameters\n    ----------\n    data: obj\n        Any object that can be converted to an :class:`arviz.InferenceData` object.\n        Refer to the documentation of :func:`arviz.convert_to_dataset` for details\n    var_names: list of variable names\n        Variables to be plotted, two variables are required. Prefix the variables with ``~``\n        when you want to exclude them from the plot.\n    filter_vars: {None, \"like\", \"regex\"}, optional, default=None\n        If `None` (default), interpret var_names as the real variables names. If \"like\",\n        interpret var_names as substrings of the real variables names. If \"regex\",\n        interpret var_names as regular expressions on the real variables names. A la\n        ``pandas.filter``.\n    combine_dims : set_like of str, optional\n        List of dimensions to reduce. Defaults to reducing only the \"chain\" and \"draw\" dimensions.\n        See the :ref:`this section <common_combine_dims>` for usage examples.\n    transform: callable\n        Function to transform data (defaults to None i.e.the identity function)\n    coords: mapping, optional\n        Coordinates of var_names to be plotted. Passed to :meth:`xarray.Dataset.sel`\n    grid : tuple\n        Number of rows and columns. Defaults to None, the rows and columns are\n        automatically inferred.\n    figsize: tuple\n        Figure size. If None it will be defined automatically.\n    textsize: float\n        Text size scaling factor for labels, titles and lines. If None it will be autoscaled based\n        on ``figsize``.\n    hdi_prob: float, optional\n        Plots highest density interval for chosen percentage of density.\n        Use 'hide' to hide the highest density interval. Defaults to 0.94.\n    multimodal: bool\n        If true (default) it may compute more than one credible interval if the distribution is\n        multimodal and the modes are well separated.\n    skipna : bool\n        If true ignores nan values when computing the hdi and point estimates. Defaults to false.\n    round_to: int, optional\n        Controls formatting of floats. Defaults to 2 or the integer part, whichever is bigger.\n    point_estimate: Optional[str]\n        Plot point estimate per variable. Values should be 'mean', 'median', 'mode' or None.\n        Defaults to 'auto' i.e. it falls back to default set in rcParams.\n    group: str, optional\n        Specifies which InferenceData group should be plotted. Defaults to 'posterior'.\n    rope: tuple or dictionary of tuples\n        Lower and upper values of the Region Of Practical Equivalence. If a list is provided, its\n        length should match the number of variables.\n    ref_val: float or dictionary of floats\n        display the percentage below and above the values in ref_val. Must be None (default),\n        a constant, a list or a dictionary like see an example below. If a list is provided, its\n        length should match the number of variables.\n    rope_color: str, optional\n        Specifies the color of ROPE and displayed percentage within ROPE\n    ref_val_color: str, optional\n        Specifies the color of the displayed percentage\n    kind: str\n        Type of plot to display (kde or hist) For discrete variables this argument is ignored and\n        a histogram is always used. Defaults to rcParam ``plot.density_kind``\n    bw: float or str, optional\n        If numeric, indicates the bandwidth and must be positive.\n        If str, indicates the method to estimate the bandwidth and must be\n        one of \"scott\", \"silverman\", \"isj\" or \"experimental\" when `circular` is False\n        and \"taylor\" (for now) when `circular` is True.\n        Defaults to \"default\" which means \"experimental\" when variable is not circular\n        and \"taylor\" when it is. Only works if `kind == kde`.\n    circular: bool, optional\n        If True, it interprets the values passed are from a circular variable measured in radians\n        and a circular KDE is used. Only valid for 1D KDE. Defaults to False.\n        Only works if `kind == kde`.\n    bins: integer or sequence or 'auto', optional\n        Controls the number of bins,accepts the same keywords :func:`matplotlib.pyplot.hist` does.\n        Only works if `kind == hist`. If None (default) it will use `auto` for continuous variables\n        and `range(xmin, xmax + 1)` for discrete variables.\n    labeller : labeller instance, optional\n        Class providing the method ``make_label_vert`` to generate the labels in the plot titles.\n        Read the :ref:`label_guide` for more details and usage examples.\n    ax: numpy array-like of matplotlib axes or bokeh figures, optional\n        A 2D array of locations into which to plot the densities. If not supplied, Arviz will create\n        its own array of plot areas (and return it).\n    backend: str, optional\n        Select plotting backend {\"matplotlib\",\"bokeh\"}. Default \"matplotlib\".\n    backend_kwargs: bool, optional\n        These are kwargs specific to the backend being used, passed to\n        :func:`matplotlib.pyplot.subplots` or :func:`bokeh.plotting.figure`\n    show: bool, optional\n        Call backend show function.\n    **kwargs\n        Passed as-is to :func:`matplotlib.pyplot.hist` or :func:`matplotlib.pyplot.plot` function\n        depending on the value of `kind`.\n\n    Returns\n    -------\n    axes: matplotlib axes or bokeh figures\n\n    See Also\n    --------\n    plot_dist : Plot distribution as histogram or kernel density estimates.\n    plot_density : Generate KDE plots for continuous variables and histograms for discrete ones.\n    plot_forest : Forest plot to compare HDI intervals from a number of distributions.\n\n    Examples\n    --------\n    Show a default kernel density plot following style of John Kruschke\n\n    .. plot::\n        :context: close-figs\n\n        >>> import arviz as az\n        >>> data = az.load_arviz_data('centered_eight')\n        >>> az.plot_posterior(data)\n\n    Plot subset variables by specifying variable name exactly\n\n    .. plot::\n        :context: close-figs\n\n        >>> az.plot_posterior(data, var_names=['mu'])\n\n    Plot Region of Practical Equivalence (rope) and select variables with regular expressions\n\n    .. plot::\n        :context: close-figs\n\n        >>> az.plot_posterior(data, var_names=['mu', '^the'], filter_vars=\"regex\", rope=(-1, 1))\n\n    Plot Region of Practical Equivalence for selected distributions\n\n    .. plot::\n        :context: close-figs\n\n        >>> rope = {'mu': [{'rope': (-2, 2)}], 'theta': [{'school': 'Choate', 'rope': (2, 4)}]}\n        >>> az.plot_posterior(data, var_names=['mu', 'theta'], rope=rope)\n\n    Using `coords` argument to plot only a subset of data\n\n    .. plot::\n        :context: close-figs\n\n        >>> coords = {\"school\": [\"Choate\",\"Phillips Exeter\"]}\n        >>> az.plot_posterior(data, var_names=[\"mu\", \"theta\"], coords=coords)\n\n    Add reference lines\n\n    .. plot::\n        :context: close-figs\n\n        >>> az.plot_posterior(data, var_names=['mu', 'theta'], ref_val=0)\n\n    Show point estimate of distribution\n\n    .. plot::\n        :context: close-figs\n\n        >>> az.plot_posterior(data, var_names=['mu', 'theta'], point_estimate='mode')\n\n    Show reference values using variable names and coordinates\n\n    .. plot::\n        :context: close-figs\n\n        >>> az.plot_posterior(data, ref_val= {\"theta\": [{\"school\": \"Deerfield\", \"ref_val\": 4},\n        ...                                             {\"school\": \"Choate\", \"ref_val\": 3}]})\n\n    Show reference values using a list\n\n    .. plot::\n        :context: close-figs\n\n        >>> az.plot_posterior(data, ref_val=[1] + [5] * 8 + [1])\n\n\n    Plot posterior as a histogram\n\n    .. plot::\n        :context: close-figs\n\n        >>> az.plot_posterior(data, var_names=['mu'], kind='hist')\n\n    Change size of highest density interval\n\n    .. plot::\n        :context: close-figs\n\n        >>> az.plot_posterior(data, var_names=['mu'], hdi_prob=.75)\n    \n\n\n\n\n\n\n","category":"method"},{"location":"api/plots/#ArviZPythonPlots.plot_ppc-Tuple","page":"Plotting functions","title":"ArviZPythonPlots.plot_ppc","text":"\n    Plot for posterior/prior predictive checks.\n\n    Parameters\n    ----------\n    data: az.InferenceData object\n        :class:`arviz.InferenceData` object containing the observed and posterior/prior\n        predictive data.\n    kind: str\n        Type of plot to display (\"kde\", \"cumulative\", or \"scatter\"). Defaults to `kde`.\n    alpha: float\n        Opacity of posterior/prior predictive density curves.\n        Defaults to 0.2 for ``kind = kde`` and cumulative, for scatter defaults to 0.7.\n    mean: bool\n        Whether or not to plot the mean posterior/prior predictive distribution.\n        Defaults to ``True``.\n    observed: bool, default True\n        Whether or not to plot the observed data.\n    observed: bool, default False\n        Whether or not to plot a rug plot for the observed data. Only valid if `observed` is\n        `True` and for kind `kde` or `cumulative`.\n    color: str\n        Valid matplotlib ``color``. Defaults to ``C0``.\n    color: list\n        List with valid matplotlib colors corresponding to the posterior/prior predictive\n        distribution, observed data and mean of the posterior/prior predictive distribution.\n        Defaults to [\"C0\", \"k\", \"C1\"].\n    grid : tuple\n        Number of rows and columns. Defaults to None, the rows and columns are\n        automatically inferred.\n    figsize: tuple\n        Figure size. If None, it will be defined automatically.\n    textsize: float\n        Text size scaling factor for labels, titles and lines. If None, it will be\n        autoscaled based on ``figsize``.\n    data_pairs: dict\n        Dictionary containing relations between observed data and posterior/prior predictive data.\n        Dictionary structure:\n\n        - key = data var_name\n        - value = posterior/prior predictive var_name\n\n        For example, ``data_pairs = {'y' : 'y_hat'}``\n        If None, it will assume that the observed data and the posterior/prior\n        predictive data have the same variable name.\n    var_names: list of variable names\n        Variables to be plotted, if `None` all variable are plotted. Prefix the\n        variables by ``~`` when you want to exclude them from the plot.\n    filter_vars: {None, \"like\", \"regex\"}, optional, default=None\n        If `None` (default), interpret var_names as the real variables names. If \"like\",\n        interpret var_names as substrings of the real variables names. If \"regex\",\n        interpret var_names as regular expressions on the real variables names. A la\n        ``pandas.filter``.\n    coords: dict\n        Dictionary mapping dimensions to selected coordinates to be plotted.\n        Dimensions without a mapping specified will include all coordinates for\n        that dimension. Defaults to including all coordinates for all\n        dimensions if None.\n    flatten: list\n        List of dimensions to flatten in ``observed_data``. Only flattens across the coordinates\n        specified in the ``coords`` argument. Defaults to flattening all of the dimensions.\n    flatten_pp: list\n        List of dimensions to flatten in posterior_predictive/prior_predictive. Only flattens\n        across the coordinates specified in the ``coords`` argument. Defaults to flattening all\n        of the dimensions. Dimensions should match flatten excluding dimensions for ``data_pairs``\n        parameters. If ``flatten`` is defined and ``flatten_pp`` is None, then\n        ``flatten_pp = flatten``.\n    num_pp_samples: int\n        The number of posterior/prior predictive samples to plot. For ``kind`` = 'scatter' and\n        ``animation = False`` if defaults to a maximum of 5 samples and will set jitter to 0.7.\n        unless defined. Otherwise it defaults to all provided samples.\n    random_seed: int\n        Random number generator seed passed to ``numpy.random.seed`` to allow\n        reproducibility of the plot. By default, no seed will be provided\n        and the plot will change each call if a random sample is specified\n        by ``num_pp_samples``.\n    jitter: float\n        If ``kind`` is \"scatter\", jitter will add random uniform noise to the height\n        of the ppc samples and observed data. By default 0.\n    animated: bool\n        Create an animation of one posterior/prior predictive sample per frame.\n        Defaults to ``False``. Only works with matploblib backend.\n        To run animations inside a notebook you have to use the `nbAgg` matplotlib's backend.\n        Try with `%matplotlib notebook` or  `%matplotlib  nbAgg`. You can switch back to the\n        default matplotlib's backend with `%matplotlib  inline` or `%matplotlib  auto`.\n        If switching back and forth between matplotlib's backend, you may need to run twice the cell\n        with the animation.\n        If you experience problems rendering the animation try setting\n        `animation_kwargs({'blit':False}`) or changing the matplotlib's backend (e.g. to TkAgg)\n        If you run the animation from a script write `ax, ani = az.plot_ppc(.)`\n    animation_kwargs : dict\n        Keywords passed to  :class:`matplotlib.animation.FuncAnimation`. Ignored with\n        matplotlib backend.\n    legend : bool\n        Add legend to figure. By default ``True``.\n    labeller : labeller instance, optional\n        Class providing the method ``make_pp_label`` to generate the labels in the plot titles.\n        Read the :ref:`label_guide` for more details and usage examples.\n    ax: numpy array-like of matplotlib axes or bokeh figures, optional\n        A 2D array of locations into which to plot the densities. If not supplied, Arviz will create\n        its own array of plot areas (and return it).\n    backend: str, optional\n        Select plotting backend {\"matplotlib\",\"bokeh\"}. Default to \"matplotlib\".\n    backend_kwargs: bool, optional\n        These are kwargs specific to the backend being used, passed to\n        :func:`matplotlib.pyplot.subplots` or :func:`bokeh.plotting.figure`.\n        For additional documentation check the plotting method of the backend.\n    group: {\"prior\", \"posterior\"}, optional\n        Specifies which InferenceData group should be plotted. Defaults to 'posterior'.\n        Other value can be 'prior'.\n    show: bool, optional\n        Call backend show function.\n\n    Returns\n    -------\n    axes: matplotlib axes or bokeh figures\n\n    See Also\n    --------\n    plot_bpv: Plot Bayesian p-value for observed data and Posterior/Prior predictive.\n    plot_lm: Posterior predictive and mean plots for regression-like data.\n    plot_ppc: plot for posterior/prior predictive checks.\n    plot_ts: Plot timeseries data.\n\n    Examples\n    --------\n    Plot the observed data KDE overlaid on posterior predictive KDEs.\n\n    .. plot::\n        :context: close-figs\n\n        >>> import arviz as az\n        >>> data = az.load_arviz_data('radon')\n        >>> az.plot_ppc(data, data_pairs={\"y\":\"y\"})\n\n    Plot the overlay with empirical CDFs.\n\n    .. plot::\n        :context: close-figs\n\n        >>> az.plot_ppc(data, kind='cumulative')\n\n    Use the ``coords`` and ``flatten`` parameters to plot selected variable dimensions\n    across multiple plots. We will now modify the dimension ``obs_id`` to contain\n    indicate the name of the county where the measure was taken. The change has to\n    be done on both ``posterior_predictive`` and ``observed_data`` groups, which is\n    why we will use :meth:`~arviz.InferenceData.map` to apply the same function to\n    both groups. Afterwards, we will select the counties to be plotted with the\n    ``coords`` arg.\n\n    .. plot::\n        :context: close-figs\n\n        >>> obs_county = data.posterior[\"County\"][data.constant_data[\"county_idx\"]]\n        >>> data = data.assign_coords(obs_id=obs_county, groups=\"observed_vars\")\n        >>> az.plot_ppc(data, coords={'obs_id': ['ANOKA', 'BELTRAMI']}, flatten=[])\n\n    Plot the overlay using a stacked scatter plot that is particularly useful\n    when the sample sizes are small.\n\n    .. plot::\n        :context: close-figs\n\n        >>> az.plot_ppc(data, kind='scatter', flatten=[],\n        >>>             coords={'obs_id': ['AITKIN', 'BELTRAMI']})\n\n    Plot random posterior predictive sub-samples.\n\n    .. plot::\n        :context: close-figs\n\n        >>> az.plot_ppc(data, num_pp_samples=30, random_seed=7)\n    \n\n\n\n\n\n\n","category":"method"},{"location":"api/plots/#ArviZPythonPlots.plot_rank-Tuple","page":"Plotting functions","title":"ArviZPythonPlots.plot_rank","text":"Plot rank order statistics of chains.\n\n    From the paper: Rank plots are histograms of the ranked posterior draws (ranked over all\n    chains) plotted separately for each chain.\n    If all of the chains are targeting the same posterior, we expect the ranks in each chain to be\n    uniform, whereas if one chain has a different location or scale parameter, this will be\n    reflected in the deviation from uniformity. If rank plots of all chains look similar, this\n    indicates good mixing of the chains.\n\n    This plot was introduced by Aki Vehtari, Andrew Gelman, Daniel Simpson, Bob Carpenter,\n    Paul-Christian Burkner (2019): Rank-normalization, folding, and localization: An improved R-hat\n    for assessing convergence of MCMC. arXiv preprint https://arxiv.org/abs/1903.08008\n\n\n    Parameters\n    ----------\n    data: obj\n        Any object that can be converted to an :class:`arviz.InferenceData` object.\n        Refer to documentation of  :func:`arviz.convert_to_dataset` for details\n    var_names: string or list of variable names\n        Variables to be plotted. Prefix the variables by ``~`` when you want to exclude\n        them from the plot.\n    filter_vars: {None, \"like\", \"regex\"}, optional, default=None\n        If `None` (default), interpret var_names as the real variables names. If \"like\",\n        interpret var_names as substrings of the real variables names. If \"regex\",\n        interpret var_names as regular expressions on the real variables names. A la\n        ``pandas.filter``.\n    transform: callable\n        Function to transform data (defaults to None i.e.the identity function)\n    coords: mapping, optional\n        Coordinates of var_names to be plotted. Passed to :meth:`xarray.Dataset.sel`\n    bins: None or passed to np.histogram\n        Binning strategy used for histogram. By default uses twice the result of Sturges' formula.\n        See :func:`numpy.histogram` documentation for, other available arguments.\n    kind: string\n        If bars (defaults), ranks are represented as stacked histograms (one per chain). If vlines\n        ranks are represented as vertical lines above or below ``ref_line``.\n    colors: string or list of strings\n        List with valid matplotlib colors, one color per model. Alternative a string can be passed.\n        If the string is `cycle`, it will automatically choose a color per model from matplotlib's\n        cycle. If a single color is passed, e.g. 'k', 'C2' or 'red' this color will be used for all\n        models. Defaults to `cycle`.\n    ref_line: boolean\n        Whether to include a dashed line showing where a uniform distribution would lie\n    labels: bool\n        whether to plot or not the x and y labels, defaults to True\n    labeller : labeller instance, optional\n        Class providing the method ``make_label_vert`` to generate the labels in the plot titles.\n        Read the :ref:`label_guide` for more details and usage examples.\n    grid : tuple\n        Number of rows and columns. Defaults to None, the rows and columns are\n        automatically inferred.\n    figsize: tuple\n        Figure size. If None it will be defined automatically.\n    ax: numpy array-like of matplotlib axes or bokeh figures, optional\n        A 2D array of locations into which to plot the densities. If not supplied, ArviZ will create\n        its own array of plot areas (and return it).\n    backend: str, optional\n        Select plotting backend {\"matplotlib\",\"bokeh\"}. Default \"matplotlib\".\n    ref_line_kwargs : dict, optional\n        Reference line keyword arguments, passed to :meth:`mpl:matplotlib.axes.Axes.axhline` or\n        :class:`bokeh:bokeh.models.Span`.\n    bar_kwargs : dict, optional\n        Bars keyword arguments, passed to :meth:`mpl:matplotlib.axes.Axes.bar` or\n        :meth:`bokeh:bokeh.plotting.Figure.vbar`.\n    vlines_kwargs : dict, optional\n        Vlines keyword arguments, passed to :meth:`mpl:matplotlib.axes.Axes.vlines` or\n        :meth:`bokeh:bokeh.plotting.Figure.multi_line`.\n    marker_vlines_kwargs : dict, optional\n        Marker for the vlines keyword arguments, passed to :meth:`mpl:matplotlib.axes.Axes.plot` or\n        :meth:`bokeh:bokeh.plotting.Figure.circle`.\n    backend_kwargs: bool, optional\n        These are kwargs specific to the backend being used, passed to\n        :func:`matplotlib.pyplot.subplots` or\n        :func:`bokeh.plotting.figure`. For additional documentation\n        check the plotting method of the backend.\n    show: bool, optional\n        Call backend show function.\n\n    Returns\n    -------\n    axes: matplotlib axes or bokeh figures\n\n    See Also\n    --------\n    plot_trace : Plot distribution (histogram or kernel density estimates) and\n                 sampled values or rank plot.\n\n    Examples\n    --------\n    Show a default rank plot\n\n    .. plot::\n        :context: close-figs\n\n        >>> import arviz as az\n        >>> data = az.load_arviz_data('centered_eight')\n        >>> az.plot_rank(data)\n\n    Recreate Figure 13 from the arxiv preprint\n\n    .. plot::\n        :context: close-figs\n\n        >>> data = az.load_arviz_data('centered_eight')\n        >>> az.plot_rank(data, var_names='tau')\n\n    Use vlines to compare results for centered vs noncentered models\n\n    .. plot::\n        :context: close-figs\n\n        >>> import matplotlib.pyplot as plt\n        >>> centered_data = az.load_arviz_data('centered_eight')\n        >>> noncentered_data = az.load_arviz_data('non_centered_eight')\n        >>> _, ax = plt.subplots(1, 2, figsize=(12, 3))\n        >>> az.plot_rank(centered_data, var_names=\"mu\", kind='vlines', ax=ax[0])\n        >>> az.plot_rank(noncentered_data, var_names=\"mu\", kind='vlines', ax=ax[1])\n\n    Change the aesthetics using kwargs\n\n    .. plot::\n        :context: close-figs\n\n        >>> az.plot_rank(noncentered_data, var_names=\"mu\", kind=\"vlines\",\n        >>>              vlines_kwargs={'lw':0}, marker_vlines_kwargs={'lw':3});\n    \n\n\n\n\n\n\n","category":"method"},{"location":"api/plots/#ArviZPythonPlots.plot_separation-Tuple","page":"Plotting functions","title":"ArviZPythonPlots.plot_separation","text":"Separation plot for binary outcome models.\n\n    Model predictions are sorted and plotted using a color code according to\n    the observed data.\n\n    Parameters\n    ----------\n    idata : InferenceData\n        :class:`arviz.InferenceData` object.\n    y : array, DataArray or str\n        Observed data. If str, ``idata`` must be present and contain the observed data group\n    y_hat : array, DataArray or str\n        Posterior predictive samples for ``y``. It must have the same shape as ``y``. If str or\n        None, ``idata`` must contain the posterior predictive group.\n    y_hat_line : bool, optional\n        Plot the sorted ``y_hat`` predictions.\n    expected_events : bool, optional\n        Plot the total number of expected events.\n    figsize : figure size tuple, optional\n        If None, size is (8 + numvars, 8 + numvars)\n    textsize: int, optional\n        Text size for labels. If None it will be autoscaled based on ``figsize``.\n    color : str, optional\n        Color to assign to the positive class. The negative class will be plotted using the\n        same color and an `alpha=0.3` transparency.\n    legend : bool, optional\n        Show the legend of the figure.\n    ax: axes, optional\n        Matplotlib axes or bokeh figures.\n    plot_kwargs : dict, optional\n        Additional keywords passed to :meth:`mpl:matplotlib.axes.Axes.bar` or\n        :meth:`bokeh:bokeh.plotting.Figure.vbar` for separation plot.\n    y_hat_line_kwargs : dict, optional\n        Additional keywords passed to ax.plot for ``y_hat`` line.\n    exp_events_kwargs : dict, optional\n        Additional keywords passed to ax.scatter for ``expected_events`` marker.\n    backend: str, optional\n        Select plotting backend {\"matplotlib\",\"bokeh\"}. Default \"matplotlib\".\n    backend_kwargs: bool, optional\n        These are kwargs specific to the backend being used, passed to\n        :func:`matplotlib.pyplot.subplots` or\n        :func:`bokeh.plotting.figure`.\n    show : bool, optional\n        Call backend show function.\n\n    Returns\n    -------\n    axes : matplotlib axes or bokeh figures\n\n    See Also\n    --------\n    plot_ppc : Plot for posterior/prior predictive checks.\n\n    References\n    ----------\n    .. [1] Greenhill, B. *et al.*, The Separation Plot: A New Visual Method\n       for Evaluating the Fit of Binary Models, *American Journal of\n       Political Science*, (2011) see https://doi.org/10.1111/j.1540-5907.2011.00525.x\n\n    Examples\n    --------\n    Separation plot for a logistic regression model.\n\n    .. plot::\n        :context: close-figs\n\n        >>> import arviz as az\n        >>> idata = az.load_arviz_data('classification10d')\n        >>> az.plot_separation(idata=idata, y='outcome', y_hat='outcome', figsize=(8, 1))\n\n    \n\n\n\n\n\n\n","category":"method"},{"location":"api/plots/#ArviZPythonPlots.plot_trace-Tuple","page":"Plotting functions","title":"ArviZPythonPlots.plot_trace","text":"Plot distribution (histogram or kernel density estimates) and sampled values or rank plot.\n\n    If `divergences` data is available in `sample_stats`, will plot the location of divergences as\n    dashed vertical lines.\n\n    Parameters\n    ----------\n    data: obj\n        Any object that can be converted to an :class:`arviz.InferenceData` object\n        Refer to documentation of :func:`arviz.convert_to_dataset` for details\n    var_names: str or list of str, optional\n        One or more variables to be plotted. Prefix the variables by ``~`` when you want\n        to exclude them from the plot.\n    filter_vars: {None, \"like\", \"regex\"}, optional, default=None\n        If `None` (default), interpret var_names as the real variables names. If \"like\",\n        interpret var_names as substrings of the real variables names. If \"regex\",\n        interpret var_names as regular expressions on the real variables names. A la\n        ``pandas.filter``.\n    coords: dict of {str: slice or array_like}, optional\n        Coordinates of var_names to be plotted. Passed to :meth:`xarray.Dataset.sel`\n    divergences: {\"bottom\", \"top\", None}, optional\n        Plot location of divergences on the traceplots.\n    kind: {\"trace\", \"rank_bars\", \"rank_vlines\"}, optional\n        Choose between plotting sampled values per iteration and rank plots.\n    transform: callable, optional\n        Function to transform data (defaults to None i.e.the identity function)\n    figsize: tuple of (float, float), optional\n        If None, size is (12, variables * 2)\n    rug: bool, optional\n        If True adds a rugplot of samples. Defaults to False. Ignored for 2D KDE.\n        Only affects continuous variables.\n    lines: list of tuple of (str, dict, array_like), optional\n        List of (var_name, {'coord': selection}, [line, positions]) to be overplotted as\n        vertical lines on the density and horizontal lines on the trace.\n    circ_var_names : str or list of str, optional\n        List of circular variables to account for when plotting KDE.\n    circ_var_units : str\n        Whether the variables in ``circ_var_names`` are in \"degrees\" or \"radians\".\n    compact: bool, optional\n        Plot multidimensional variables in a single plot.\n    compact_prop: str or dict {str: array_like}, optional\n         Defines the property name and the property values to distinguish different\n        dimensions with compact=True.\n        When compact=True it defaults to color, it is\n        ignored otherwise.\n    combined: bool, optional\n        Flag for combining multiple chains into a single line. If False (default), chains will be\n        plotted separately.\n    chain_prop: str or dict {str: array_like}, optional\n        Defines the property name and the property values to distinguish different chains.\n        If compact=True it defaults to linestyle,\n        otherwise it uses the color to distinguish\n        different chains.\n    legend: bool, optional\n        Add a legend to the figure with the chain color code.\n    plot_kwargs, fill_kwargs, rug_kwargs, hist_kwargs: dict, optional\n        Extra keyword arguments passed to :func:`arviz.plot_dist`. Only affects continuous\n        variables.\n    trace_kwargs: dict, optional\n        Extra keyword arguments passed to :meth:`matplotlib.axes.Axes.plot`\n    labeller : labeller instance, optional\n        Class providing the method ``make_label_vert`` to generate the labels in the plot titles.\n        Read the :ref:`label_guide` for more details and usage examples.\n    rank_kwargs : dict, optional\n        Extra keyword arguments passed to :func:`arviz.plot_rank`\n    axes: axes, optional\n        Matplotlib axes or bokeh figures.\n    backend: {\"matplotlib\", \"bokeh\"}, optional\n        Select plotting backend.\n    backend_config: dict, optional\n        Currently specifies the bounds to use for bokeh axes. Defaults to value set in rcParams.\n    backend_kwargs: dict, optional\n        These are kwargs specific to the backend being used, passed to\n        :func:`matplotlib.pyplot.subplots` or\n        :func:`bokeh.plotting.figure`.\n    show: bool, optional\n        Call backend show function.\n\n    Returns\n    -------\n    axes: matplotlib axes or bokeh figures\n\n    See Also\n    --------\n    plot_rank : Plot rank order statistics of chains.\n\n    Examples\n    --------\n    Plot a subset variables and select them with partial naming\n\n    .. plot::\n        :context: close-figs\n\n        >>> import arviz as az\n        >>> data = az.load_arviz_data('non_centered_eight')\n        >>> coords = {'school': ['Choate', 'Lawrenceville']}\n        >>> az.plot_trace(data, var_names=('theta'), filter_vars=\"like\", coords=coords)\n\n    Show all dimensions of multidimensional variables in the same plot\n\n    .. plot::\n        :context: close-figs\n\n        >>> az.plot_trace(data, compact=True)\n\n    Display a rank plot instead of trace\n\n    .. plot::\n        :context: close-figs\n\n        >>> az.plot_trace(data, var_names=[\"mu\", \"tau\"], kind=\"rank_bars\")\n\n    Combine all chains into one distribution and select variables with regular expressions\n\n    .. plot::\n        :context: close-figs\n\n        >>> az.plot_trace(\n        >>>     data, var_names=('^theta'), filter_vars=\"regex\", coords=coords, combined=True\n        >>> )\n\n\n    Plot reference lines against distribution and trace\n\n    .. plot::\n        :context: close-figs\n\n        >>> lines = (('theta_t',{'school': \"Choate\"}, [-1]),)\n        >>> az.plot_trace(data, var_names=('theta_t', 'theta'), coords=coords, lines=lines)\n\n    \n\n\n\n\n\n\n","category":"method"},{"location":"api/plots/#ArviZPythonPlots.plot_violin-Tuple","page":"Plotting functions","title":"ArviZPythonPlots.plot_violin","text":"Plot posterior of traces as violin plot.\n\n    Notes\n    -----\n    If multiple chains are provided for a variable they will be combined\n\n    Parameters\n    ----------\n    data: obj\n        Any object that can be converted to an :class:`arviz.InferenceData` object\n        Refer to documentation of :func:`arviz.convert_to_dataset` for details\n    var_names: list of variable names, optional\n        Variables to be plotted, if None all variable are plotted. Prefix the\n        variables by ``~`` when you want to exclude them from the plot.\n    combine_dims : set_like of str, optional\n        List of dimensions to reduce. Defaults to reducing only the \"chain\" and \"draw\" dimensions.\n        See the :ref:`this section <common_combine_dims>` for usage examples.\n    filter_vars: {None, \"like\", \"regex\"}, optional, default=None\n        If `None` (default), interpret var_names as the real variables names. If \"like\",\n        interpret var_names as substrings of the real variables names. If \"regex\",\n        interpret var_names as regular expressions on the real variables names. A la\n        ``pandas.filter``.\n    transform: callable\n        Function to transform data (defaults to None i.e. the identity function).\n    quartiles: bool, optional\n        Flag for plotting the interquartile range, in addition to the ``hdi_prob`` * 100%\n        intervals. Defaults to ``True``.\n    rug: bool\n        If ``True`` adds a jittered rugplot. Defaults to ``False``.\n    side : {\"both\", \"left\", \"right\"}, default \"both\"\n        If ``both``, both sides of the violin plot are rendered. If ``left`` or ``right``, only\n        the respective side is rendered. By separately plotting left and right halfs with\n        different data, split violin plots can be achieved.\n    hdi_prob: float, optional\n        Plots highest posterior density interval for chosen percentage of density.\n        Defaults to 0.94.\n    shade: float\n        Alpha blending value for the shaded area under the curve, between 0\n        (no shade) and 1 (opaque). Defaults to 0.\n    bw: float or str, optional\n        If numeric, indicates the bandwidth and must be positive.\n        If str, indicates the method to estimate the bandwidth and must be\n        one of \"scott\", \"silverman\", \"isj\" or \"experimental\" when ``circular`` is ``False``\n        and \"taylor\" (for now) when ``circular`` is ``True``.\n        Defaults to \"default\" which means \"experimental\" when variable is not circular\n        and \"taylor\" when it is.\n    circular: bool, optional.\n        If ``True``, it interprets `values` is a circular variable measured in radians\n        and a circular KDE is used. Defaults to ``False``.\n    grid : tuple\n        Number of rows and columns. Defaults to None, the rows and columns are\n        automatically inferred.\n    figsize: tuple\n        Figure size. If None it will be defined automatically.\n    textsize: int\n        Text size of the point_estimates, axis ticks, and highest density interval. If None it will\n        be autoscaled based on ``figsize``.\n    labeller : labeller instance, optional\n        Class providing the method ``make_label_vert`` to generate the labels in the plot titles.\n        Read the :ref:`label_guide` for more details and usage examples.\n    sharex: bool\n        Defaults to ``True``, violinplots share a common x-axis scale.\n    sharey: bool\n        Defaults to ``True``, violinplots share a common y-axis scale.\n    ax: numpy array-like of matplotlib axes or bokeh figures, optional\n        A 2D array of locations into which to plot the densities. If not supplied, Arviz will create\n        its own array of plot areas (and return it).\n    shade_kwargs: dicts, optional\n        Additional keywords passed to :meth:`matplotlib.axes.Axes.fill_between`, or\n        :meth:`matplotlib.axes.Axes.barh` to control the shade.\n    rug_kwargs: dict\n        Keywords passed to the rug plot. If true only the right half side of the violin will be\n        plotted.\n    backend: str, optional\n        Select plotting backend {\"matplotlib\",\"bokeh\"}. Default to \"matplotlib\".\n    backend_kwargs: bool, optional\n        These are kwargs specific to the backend being used, passed to\n        :func:`matplotlib.pyplot.subplots` or :func:`bokeh.plotting.figure`.\n        For additional documentation check the plotting method of the backend.\n    show: bool, optional\n        Call backend show function.\n\n    Returns\n    -------\n    axes: matplotlib axes or bokeh figures\n\n    See Also\n    --------\n    plot_forest: Forest plot to compare HDI intervals from a number of distributions.\n\n    Examples\n    --------\n    Show a default violin plot\n\n    .. plot::\n        :context: close-figs\n\n        >>> import arviz as az\n        >>> data = az.load_arviz_data('centered_eight')\n        >>> az.plot_violin(data)\n\n    \n\n\n\n\n\n\n","category":"method"}]
}
