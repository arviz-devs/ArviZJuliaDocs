import{_ as e,c as t,o as a,V as o}from"./chunks/framework.-hqW-2cI.js";const y=JSON.parse('{"title":"Extending DimensionalData","description":"","frontmatter":{},"headers":[],"relativePath":"ext_dd.md","filePath":"ext_dd.md","lastUpdated":null}'),i={name:"ext_dd.md"},s=o('<h1 id="Extending-DimensionalData" tabindex="-1">Extending DimensionalData <a class="header-anchor" href="#Extending-DimensionalData" aria-label="Permalink to &quot;Extending DimensionalData {#Extending-DimensionalData}&quot;">​</a></h1><p>Nearly everything in DimensionalData.jl is designed to be extensible.</p><ul><li><p><code>AbstractDimArray</code> are easily extended to custom array types. <code>Raster</code> or <code>YAXArray</code> are examples from other packages.</p></li><li><p><code>AbstractDimStack</code> are easily extended to custom mixed array dataset. <code>RasterStack</code> or <code>ArViZ.Dataset</code> are examples.</p></li><li><p><code>LookupArray</code> can have new types added, e.g. to <code>AbstractSampled</code> or <code>AbstractCategorical</code>. <code>Rasters.Projected</code> is a lookup that knows its coordinate reference system, but otherwise behaves as a regular <code>Sampled</code> lookup.</p></li></ul><p><code>dims</code>, <code>rebuild</code> and <code>format</code> are the key interface methods in most of these cases.</p><h2 id="dims" tabindex="-1"><code>dims</code> <a class="header-anchor" href="#dims" aria-label="Permalink to &quot;`dims` {#dims}&quot;">​</a></h2><p>Objects extending DimensionalData.jl that have dimensions must return a <code>Tuple</code> of constructed <code>Dimension</code>s from <code>dims(obj)</code>.</p><h3 id="Dimension-axes" tabindex="-1"><code>Dimension</code> axes <a class="header-anchor" href="#Dimension-axes" aria-label="Permalink to &quot;`Dimension` axes {#Dimension-axes}&quot;">​</a></h3><p>Dimensions return from <code>dims</code> should hold a <code>LookupArray</code> or in some cases just an <code>AbstractArray</code> (like wiht <code>DimIndices</code>). When attached to mullti-dimensional objects, lookups must be the <em>same length</em> as the axis of the array it represents, and <code>eachindex(A, i)</code> and <code>eachindex(dim)</code> must return the same values.</p><p>This means that if the array has OffsetArrays.jl axes, the array the dimension wraps must also have OffsetArrays.jl axes.</p><h3 id="dims-keywords" tabindex="-1"><code>dims</code> keywords <a class="header-anchor" href="#dims-keywords" aria-label="Permalink to &quot;`dims` keywords {#dims-keywords}&quot;">​</a></h3><p>To any <code>dims</code> keyword argument that only marks the dimension name, objects should accept any <code>Dimension</code>, <code>Type{&lt;:Dimension}</code>, <code>Symbol</code>, <code>Val{:Symbol}</code>, <code>Val{&lt;:Type{&lt;:Dimension}}</code> or regular <code>Integer</code>. This is easier than it sounds, calling <code>DD.dims(objs, dims)</code> will return the matching dimension and <code>DD.dimnum(obj, dims)</code> will return the matching <code>Int</code> for any of these inputs as long as <code>dims(obj)</code> is implemented.</p><h2 id="rebuild" tabindex="-1"><code>rebuild</code> <a class="header-anchor" href="#rebuild" aria-label="Permalink to &quot;`rebuild` {#rebuild}&quot;">​</a></h2><p>Rebuild methods are used to rebuild immutable objects with new field values, in a way that is more flexible and extensible than just using ConstructionBase.jl reconstruction. Developers can choose to ignore some of the fields passed by <code>rebuild</code>.</p><p>The function signature is always one of:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">rebuild</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(obj, args</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>\n<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">rebuild</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(obj; kw</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p><code>rebuild</code> has keyword versions automatically generated for all objects using <a href="https://github.com/JuliaObjects/ConstructionBase.jl" target="_blank" rel="noreferrer">ConstructionBase.jl</a>.</p><p>These will work without further work as long as your object has the fields used by DimensionalData.jl objects. For example, <code>AbstractDimArray</code> will receive these keywords in <code>rebuild</code>: <code>data</code>, <code>dims</code>, <code>refdims</code>, <code>name</code>, <code>metadata</code>.</p><p>If your <code>AbstractDimArray</code> does not have all these fields, you must implement <code>rebuild(x::YourDimArray; kw...)</code> manually.</p><p>An argument method is also defined with the same arguments as the keyword version. For <code>AbstractDimArray</code> it should only be used for updating <code>data</code> and <code>dims</code>, any more that that is confusing.</p><p>For <code>Dimension</code> and <code>Selector</code> the single argument versions are easiest to use, as there is only one argument.</p><h3 id="rebuild(obj,-...)-argument-table" tabindex="-1"><code>rebuild(obj, ...)</code> argument table <a class="header-anchor" href="#rebuild(obj,-...)-argument-table" aria-label="Permalink to &quot;`rebuild(obj, ...)` argument table {#rebuild(obj,-...)-argument-table}&quot;">​</a></h3><table><thead><tr><th style="text-align:right;">Type</th><th style="text-align:right;">Keywords</th><th style="text-align:right;">Arguments</th></tr></thead><tbody><tr><td style="text-align:right;">AbstractDimArray</td><td style="text-align:right;">data, dims, [refdims, name, metadata]</td><td style="text-align:right;">as with kw, in order</td></tr><tr><td style="text-align:right;">AbstractDimStack</td><td style="text-align:right;">data, dims, [refdims], layerdims, [metadata, layermetadata]</td><td style="text-align:right;">as with kw, in order</td></tr><tr><td style="text-align:right;">Dimension</td><td style="text-align:right;">val</td><td style="text-align:right;">val</td></tr><tr><td style="text-align:right;">Selector</td><td style="text-align:right;">val, [atol]</td><td style="text-align:right;">val</td></tr><tr><td style="text-align:right;">LookupArray</td><td style="text-align:right;">data, [order, span, sampling, metadata]</td><td style="text-align:right;">keywords only</td></tr></tbody></table><p>You can always add your ownd keywords to <code>rebuild</code> calls, but these will only work on your own objects or other objects with those fields.</p><h2 id="format" tabindex="-1"><code>format</code> <a class="header-anchor" href="#format" aria-label="Permalink to &quot;`format` {#format}&quot;">​</a></h2><p>When constructing an <code>AbstractDimArray</code> or <code>AbstractDimStack</code> <a href="/DimensionalData.jl/dev/api/dimensions#DimensionalData.Dimensions.format"><code>DimensionalData.format</code></a> must be called on the <code>dims</code> tuple and the parent array:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">dims</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">`format(dims, array)`</span></span></code></pre></div><p>This lets DimensionalData detect the lookup properties, fill in missing fields of LookupArray, pass keywords from <code>Dimension</code> to detected <code>LookupArray</code>, and accept a wider range of dimension inputs like tuples of <code>Symbol</code> and <code>Type</code>.</p><p>Not calling <code>format</code> whille constructing an <code>AbstractDimArray</code> has undefined behaviour.</p>',28),d=[s];function r(n,l,c,h,m,p){return a(),t("div",null,d)}const g=e(i,[["render",r]]);export{y as __pageData,g as default};
