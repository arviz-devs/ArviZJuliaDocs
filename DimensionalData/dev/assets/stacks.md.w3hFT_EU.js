import{_ as e,c as a,o as t,V as o}from"./chunks/framework.-hqW-2cI.js";const u=JSON.parse('{"title":"Stacks","description":"","frontmatter":{},"headers":[],"relativePath":"stacks.md","filePath":"stacks.md","lastUpdated":null}'),s={name:"stacks.md"},c=o('<h1 id="Stacks" tabindex="-1">Stacks <a class="header-anchor" href="#Stacks" aria-label="Permalink to &quot;Stacks {#Stacks}&quot;">​</a></h1><p>An <code>AbstractDimStack</code> represents a collection of <code>AbstractDimArray</code> layers that share some or all dimensions. For any two layers, a dimension of the same name must have the identical lookup - in fact only one is stored for all layers to enforce this consistency.</p><p>The behaviour is somewhere ebetween a <code>NamedTuple</code> and an <code>AbstractArray</code></p><p>Indexing layers by name with <code>stack[:layer]</code> or <code>stack.layer</code> works as with a <code>NamedTuple</code>, and returns an <code>AbstractDimArray</code>. Indexing with <code>Dimensions</code>, <code>Selectors</code> works as with an <code>AbstractDimArray</code>, except it indexes for all layers at the same time, returning either a new small <code>AbstractDimStack</code> or a scalar value, if all layers are scalars.</p><p>Base functions like <code>mean</code>, <code>maximum</code>, <code>reverse</code> are applied to all layers of the stack.</p><p><code>broadcast_dims</code> broadcasts functions over any mix of <code>AbstractDimStack</code> and <code>AbstractDimArray</code> returning a new <code>AbstractDimStack</code> with layers the size of the largest layer in the broadcast. This will work even if dimension permutation does not match in the objects.</p><h1 id="Performance" tabindex="-1">Performance <a class="header-anchor" href="#Performance" aria-label="Permalink to &quot;Performance {#Performance}&quot;">​</a></h1><p>Indexing stack is fast - indexing a single value return a <code>NamedTuple</code> from all layers usingally, measures in nanoseconds. There are some compilation overheads to this though, and stacks with very many layers can take a long time to compile.</p><p>Hopefully compiler fixes planned for Julia v1.11 will improve this.</p>',9),r=[c];function n(i,d,l,m,h,p){return t(),a("div",null,r)}const k=e(s,[["render",n]]);export{u as __pageData,k as default};
