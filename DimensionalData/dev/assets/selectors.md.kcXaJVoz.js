import{_ as t,c as e,o as a,V as l}from"./chunks/framework.-hqW-2cI.js";const f=JSON.parse('{"title":"Selectors and LookupArrays","description":"","frontmatter":{},"headers":[],"relativePath":"selectors.md","filePath":"selectors.md","lastUpdated":null}'),o={name:"selectors.md"},r=l('<h1 id="Selectors-and-LookupArrays" tabindex="-1">Selectors and LookupArrays <a class="header-anchor" href="#Selectors-and-LookupArrays" aria-label="Permalink to &quot;Selectors and LookupArrays {#Selectors-and-LookupArrays}&quot;">â€‹</a></h1><p><a href="http://localhost:5173/DimensionalData.jl/reference#lookuparrays" target="_blank" rel="noreferrer">http://localhost:5173/DimensionalData.jl/reference#lookuparrays</a></p><p>DimensionalData.jl <a href="./@ref"><code>Dimension</code></a>s in an <code>AbstractDimArray</code> or <code>AbstactDimStack</code> usually hold <a href="./api/lookuparrays#DimensionalData.Dimensions.LookupArrays"><code>LookupArrays</code></a>.</p><p>These are <code>AbstractArray</code> with added features to facilitate fast and accurate lookups of their values, using a <a href="./@ref"><code>Selector</code></a></p><table><thead><tr><th style="text-align:left;">Selector</th><th style="text-align:left;">Description</th><th style="text-align:right;">Indexing style</th></tr></thead><tbody><tr><td style="text-align:left;">[`At(x)`](api/lookuparrays#DimensionalData.Dimensions.LookupArrays.At)</td><td style="text-align:left;">get the index exactly matching the passed in value(s)</td><td style="text-align:right;">`Int/Vector{Int}`</td></tr><tr><td style="text-align:left;">[`Near(x)`](api/lookuparrays#DimensionalData.Dimensions.LookupArrays.Near)</td><td style="text-align:left;">get the closest index to the passed in value(s)</td><td style="text-align:right;">`Int/Vector{Int}`</td></tr><tr><td style="text-align:left;">[`Contains(x)`](api/lookuparrays#DimensionalData.Dimensions.LookupArrays.Contains)</td><td style="text-align:left;">get indices where the value x falls within an interval in the lookup</td><td style="text-align:right;">`Int/Vector{Int}`</td></tr><tr><td style="text-align:left;">[`Where(f)`](api/lookuparrays#DimensionalData.Dimensions.LookupArrays.Where)</td><td style="text-align:left;">filter the array axis by a function of the dimension index values.</td><td style="text-align:right;">`Vector{Bool}`</td></tr><tr><td style="text-align:left;">[`Not(x)`]</td><td style="text-align:left;">get all indices _not_ selected by `x`, which can be another selector.</td><td style="text-align:right;">`Vector{Bool}`</td></tr><tr><td style="text-align:left;">[`a .. b`]</td><td style="text-align:left;">get all indices between two values, inclusively.</td><td style="text-align:right;">`UnitRange`</td></tr><tr><td style="text-align:left;">[`OpenInterval(a, b)`]</td><td style="text-align:left;">get all indices between `a` and `b`, exclusively.</td><td style="text-align:right;">`UnitRange`</td></tr><tr><td style="text-align:left;">[`Interval{A,B}(a, b)`]</td><td style="text-align:left;">get all indices between `a` and `b`, as `:closed` or `:open`.</td><td style="text-align:right;">`UnitRange`</td></tr><tr><td style="text-align:left;">[`Touches(a, b)`]</td><td style="text-align:left;">like `..` but includes all cells touched by the interval, not just inside it</td><td style="text-align:right;">`UnitRange`</td></tr></tbody></table><p>Note: <code>At</code>, <code>Near</code> and <code>Contains</code> can wrap either single values or an <code>AbstractArray</code> of values, to select one index with an <code>Int</code> or multiple indices with a <code>Vector{Int}</code>.</p><p>Selectors find indices in the <code>LookupArray</code>, for each dimension. LookupArrays wrap other <code>AbstractArray</code> (often <code>AbstractRange</code>) but add aditional traits to facilitate fast lookups or specifing point or interval behviour.</p><p>Some common <code>LookupArray</code> that are:</p><table><thead><tr><th style="text-align:left;">LookupArray</th><th style="text-align:left;">Description</th></tr></thead><tbody><tr><td style="text-align:left;">[`Sampled(x)`](@ref)</td><td style="text-align:left;">values sampled along an axis - may be `Ordered`/`Unordered`, `Intervals`/`Points`, and `Regular`/`Irregular`</td></tr><tr><td style="text-align:left;">[`Categorical(x)`](@ref)</td><td style="text-align:left;">a categorical lookup that holds categories, and may be ordered</td></tr><tr><td style="text-align:left;">[`Cyclic(x)`](@ref)</td><td style="text-align:left;">an `AbstractSampled` lookup for cyclical values.</td></tr><tr><td style="text-align:left;">[`NoLookup(x)`](@ref)</td><td style="text-align:left;">no lookup values provided, so `Selector`s will not work. Not show in repl printing.</td></tr></tbody></table>',9),n=[r];function s(i,d,c,y,p,h){return a(),e("div",null,n)}const u=t(o,[["render",s]]);export{f as __pageData,u as default};
